/*!
 * democapsid v2.1.0 - Render viral capsids in the browser and export SVG.
 * MIT License
 * Copyright (c) 2020 - 2024, Daniel Antonio Negrón (dnanto/remaindeer)
 */
const r="2.1.0",o=Math.sqrt(3),e=Math.sqrt(5),n=(1+e)/2,a=100,s=1e-15,i=1e-5;function mmul(t,r){const[o,e,n]=[t.length,t[0].length,r[0].length];for(var a=new Array(o),s=0;s<o;s++)a[s]=new Array(n).fill(0);for(s=0;s<o;s++)for(var i=0;i<n;i++)for(var c=0;c<e;c++)a[s][i]+=t[s][c]*r[c][i];return a}function det2(t){return t[0][0]*t[1][1]-t[0][1]*t[1][0]}function det3(t){return t[0][0]*(t[1][1]*t[2][2]-t[1][2]*t[2][1])-t[0][1]*(t[1][0]*t[2][2]-t[1][2]*t[2][0])+t[0][2]*(t[1][0]*t[2][1]-t[1][1]*t[2][0])}function inv2(t){const r=det2(t);return[[t[1][1],-t[0][1]].div(r),[-t[1][0],t[0][0]].div(r)]}function inv3(t){const[r,o,e,n,a,s,i,c,l]=[t[0][0],t[0][1],t[0][2],t[1][0],t[1][1],t[1][2],t[2][0],t[2][1],t[2][2]],d=this.det3(t);return[[(a*l-s*c)/d,-(o*l-e*c)/d,(o*s-e*a)/d],[-(n*l-s*i)/d,(r*l-e*i)/d,-(r*s-e*n)/d],[(n*c-a*i)/d,-(r*c-o*i)/d,(r*a-o*n)/d]]}function T(t){for(var r=Array.from({length:t[0].length},(()=>Array.from({length:t.length},(()=>[])))),o=0;o<r.length;o++)r[o]=new Array(t.length);for(o=0;o<t.length;o++)for(var e=0;e<t[0].length;e++)r[e][o]=t[o][e];return r}function rotmat3(t,r,o){const[e,n,a,s,i,c]=[Math.sin(t),Math.sin(r),Math.sin(o),Math.cos(t),Math.cos(r),Math.cos(o)];return[[s*i,s*n*a-e*c,s*n*c+e*a],[e*i,e*n*a+s*c,e*n*c-s*a],[-n,i*a,i*c]]}function camera(t,r,o,e=[0,0,0]){const n=rotmat3(t,r,o),a=[[1,0,0,-e[0]],[0,1,0,-e[1]],[0,0,1,-e[2]]];return mmul(mmul([[1,0,0],[0,1,0],[0,0,1]],n),a)}function*brackets(t,r,o,e){const n=o/e;let a=Math.sign(t(r));for(let s=0;s<e;s++){let o=r+s*n,e=Math.sign(t(o));a!=e&&(yield[r+(s-1)*n,o],a=e)}}function bisection(t,r,o,e,n){let a=1,s=(r+o)/2,i=t(s);for(;a<=n&&(s=(r+o)/2,i=t(s),!(0==i||(o-r)/2<e));a++)Math.sign(i)==Math.sign(t(r))?r=s:o=s;return[a,i,s]}function degrees(t){return 180*t/Math.PI}function radians(t){return t*Math.PI/180}function calc_tile(t,r){const e=r*(o/2);let n;if("hex"===t)n={basis:[[2*e,0],[e,o*e]],tile:t=>[new Path.RegularPolygon({center:t.coor,sides:6,radius:r,data:{mer:1}})],radius:r};else if("trihex"===t)n={basis:[[2*r,0],[r,r*o]],tile:t=>[new Path.RegularPolygon({center:t.coor,sides:6,radius:r,data:{mer:1}}).rotate(30),...Array.from({length:2},((o,n)=>new Path.RegularPolygon({center:t.coor.add([r,-1/3*e]),sides:3,radius:2/3*e,data:{mer:2}}).rotate(180).rotate(60*n,t.coor)))],radius:2*e};else if("snubhex"===t)n={basis:[[2.5*r,e],[.5*r,3*e]],tile:t=>[new Path.RegularPolygon({center:t.coor,sides:6,radius:r,data:{mer:1}}).rotate(30),...Array.from({length:6},((r,o)=>new Path.RegularPolygon({center:t.coor.add([0,-e-1/3*e]),sides:3,radius:2/3*e,data:{mer:2}}).rotate(60*o,t.coor))),new Path.RegularPolygon({center:t.coor.add([1.5*r,-1/3*e]),sides:3,radius:2/3*e,data:{mer:2}}),new Path.RegularPolygon({center:t.coor.add([-1.5*r,2/3*e]),sides:3,radius:2/3*e,data:{mer:2}}).rotate(180)],radius:2*e};else if("rhombitrihex"===t)n={basis:[[r+e+.5*r,.5*r+e],[0,2*e+r]],tile:t=>[new Path.RegularPolygon({center:t.coor,sides:6,radius:r,data:{mer:1}}).rotate(30),...Array.from({length:3},((e,n)=>new Path.RegularPolygon({center:t.coor.add([0,r+r*(o/3)]),sides:3,radius:r/o,data:{mer:2}}).rotate(-60*n-30,t.coor))),...Array.from({length:3},((o,n)=>new Path.RegularPolygon({center:t.coor.add([0,-e-.5*r]),sides:4,radius:Math.sqrt(2*r*r)/2,data:{mer:3}}).rotate(60*n,t.coor)))],radius:Math.sqrt(Math.pow(e+r,2)+Math.pow(r/2,2))};else if("dualhex"===t)n={basis:[[1.5*r,e],[0,2*e]],tile:t=>Array.from({length:6},((n,a)=>new Path.RegularPolygon({center:t.coor.add([0,e-r*o/6]),sides:3,radius:r/o,data:{mer:1}}).rotate(60*a,t.coor))),radius:r};else if("dualtrihex"===t)n={basis:[[2*e,0],[e,o*e]],tile:t=>[...Array.from({length:6},((o,n)=>new Path({segments:[[0,0],[.5*e,-.25*r*Math.sin(Math.PI/6)/Math.cos(Math.PI/3)],[e,0],[.5*e,.25*r*Math.sin(Math.PI/6)/Math.cos(Math.PI/3)]].map((r=>t.coor.add(r))),closed:!0,data:{mer:1}}).rotate(60*n,t.coor))),...Array.from({length:6},((o,n)=>new Path({segments:[[-.5*e,.5*r+.25*r*Math.sin(Math.PI/6)/Math.cos(Math.PI/3)],[0,.5*r],[e-.5*e,.5*r+.25*r*Math.sin(Math.PI/6)/Math.cos(Math.PI/3)],[0,.5*r+.25*r*Math.sin(Math.PI/6)*2/Math.cos(Math.PI/3)]].map((r=>t.coor.add(r))),closed:!0,data:{mer:2}}).rotate(60*n,t.coor)))],radius:r};else if("dualsnubhex"===t)n={basis:[[2.5*r,e],[.5*r,2*e+r*o/3*2-r*o/6]],tile:t=>Array.from({length:6},((n,a)=>new Path({segments:[[0,0],[0,e+r*o/6],[.5*r,e+r*o/3],[r,e+r*o/6],[r,r*o/3]].map((r=>t.coor.add(r))),closed:!0,data:{mer:1}}).rotate(60*a,t.coor))),radius:e+r*o/3};else{if("dualrhombitrihex"!==t)throw new Error("incorrect tile mode");n={basis:[[1.5*r,e],[0,2*e]],tile:t=>Array.from({length:6},((n,a)=>new Path({segments:[[0,0],[0,e],[.5*r,e],[o/2*e,.5*e]].map((r=>t.coor.add(r))),closed:!0,data:{mer:1}}).rotate(60*a,t.coor))),radius:r}}return n}function*tile_grid(t,r){const o=t.map((t=>mmul(T(inv2(r)),[t,1].flat().T()).flat())).map((t=>t.map(Math.round))),[e,n,a,s]=[...[0,1].map(((t,r)=>Math.min(...o.map((t=>t[r]))))),...[0,1].map(((t,r)=>Math.max(...o.map((t=>t[r])))))];for(let i=e;i<a+1;i++)for(let t=n;t<s+1;t++)yield{index:[i,t],coor:r[0].mul(i).add(r[1].mul(t)),is_vertex:o.has([i,t])}}function ck_vectors(t,r,o,e,n){const[a,s]=t,i=s.rot(Math.PI/3);return[a.mul(r).add(s.mul(o)),s.mul(e).add(i.mul(n)),a.mul(-r-o).add(s.mul(r)),a.mul(o).add(i.mul(-r))]}function triangle_circumcircle_center(t,r,o){const[e,n]=[t.sub(o),r.sub(o)],a=e.cross(n);return n.mul(e.norm()**2).sub(e.mul(n.norm()**2)).cross(a).div(2*a.norm()**2).add(o)}function tetrahedron_circumsphere_center(t,r,o,e){const[n,a,s]=[r,o,e].map((r=>r.sub(t)));return t.add(n.cross(a).mul(s.norm()**2).add(s.cross(n).mul(a.norm()**2)).add(a.cross(s).mul(n.norm()**2)).div(2*det3([n,a,s])))}function body_radius(t){return t[6].sub([0,0,t[6][2]]).norm()}function height(t){return t[0][2]-t[19][2]}function body_height(t){return t[4][2]-t[6][2]}function sd_sphere(t,r){return t.norm()-r}function spherize(t,r,o){return t.uvec().mul(Math.abs(sd_sphere(t,r))*o).add(t)}function cylinderize(t,r,o,e){const[n,a]=[body_radius(r),body_height(r)/2];let s,i;if(5===o)s=[0,0,a-n/2],i=r[0][2]+n/2-a;else if(3===o){const[t,o]=[r[0],r[3]];s=triangle_circumcircle_center(t,o,[o[0],-o[1],o[2]]),i=t.sub(s).norm()}else 2===o&&(p1=r[0],s=tetrahedron_circumsphere_center(p1,...[1,4,5].map((t=>r[t]))),i=p1.sub(s).norm());const[c,l,d,u]=[[0,0,s[2]],[0,0,-s[2]],[0,0,a],[0,0,-a]];if(a<t[2]){const r=Math.abs(sd_sphere(t.sub(c),i));return t.sub(d).uvec().mul(r*e).add(t)}if(t[2]<-a){const r=Math.abs(sd_sphere(t.sub(l),i));return t.sub(u).uvec().mul(r*e).add(t)}return t.sub([0,0,t[2]]).uvec().mul((n-t.slice(0,2).norm())*e).add(t)}function ico_config(t){let r;if(5===t)r=[[1,1,2,2],["T1-▲","T1-▼","T2-▲","T2-▼"],[[0,1,2],[6,11,7],[2,1,6],[6,7,2]],[5,5,5,5],[[1,2,3,4,5],[0,2,5,6,10],[0,1,3,6,7],[0,2,4,7,8],[0,3,5,8,9],[0,1,4,9,10],[1,2,7,10,11],[2,3,6,8,11],[3,4,7,9,11],[4,5,8,10,11],[1,5,6,9,11],[6,7,8,9,10]]];else if(3===t)r=[[1,1,1,1,2,2,3,3],["T1-▔","T1-▲","T1-▼","T1-▁","T2-▼","T2-▲","T3-▼","T3-▲"],[[0,2,1],[1,2,3],[6,9,11],[9,10,11],[1,3,6],[9,6,3],[1,6,5],[11,5,6]],[1,3,3,1,3,3,3,3],[[1,2,4,5,8],[0,2,3,5,6],[0,1,3,4,7],[1,2,6,7,9],[0,2,7,8,10],[0,1,6,8,11],[1,3,5,9,11],[2,3,4,9,10],[0,4,5,10,11],[3,6,7,10,11],[4,7,8,9,11],[5,6,8,9,10]]];else{if(2!==t)throw new Error("a must be 2, 3, or 5");r=[[1,1,1,1,2,2,2,2,3,3],["T1-▔","T1-▔","T1▁","T1▁","T2-▼","T2-▲","T2-▼","T2-▲","T3-▼","T3-▲"],[[0,1,2],[2,1,4],[9,10,6],[9,11,10],[0,2,6],[9,6,2],[2,4,9],[11,9,4],[0,6,5],[10,5,6]],[2,2,2,2,2,2,2,2,2,2],[[1,2,3,5,6],[0,2,3,4,7],[0,1,4,6,9],[0,1,5,7,8],[1,2,7,9,11],[0,3,6,8,10],[0,2,5,9,10],[1,3,4,8,11],[3,5,7,10,11],[2,4,6,10,11],[5,6,8,9,11],[4,7,8,9,10]]]}return Object.fromEntries(["t_idx","t_id","v_idx","t_rep","v_con"].map(((t,o)=>[t,r[o]])))}function ico_axis_5(t){const[r,o]=[t[0].norm(),t[1].norm()],n=r*Math.sqrt((5+e)/10),a=[0,0,(1+e)*r/(2*Math.sqrt(5+2*e))],s=[-n,0,0].roro([0,0,1],.3*Math.PI),i=s.add([r,0,0]),c=t[0].angle(t[1]),l=i.add([o,0,0].roro([0,1,0],-Math.PI-c)),d=s.add(l.sub(s).proj(i.sub(s))),u=[d[0],-Math.abs(d[1])*Math.sqrt(n*n*d[1]*d[1]-(d[0]*d[1])**2)/(d[1]*d[1]),0];if(Number.isNaN(u[1]))throw new Error("impossible construction!");const h=u.add([0,0,-Math.sqrt(l[2]*l[2]-(d[1]-u[1])**2)]);return[a,s,i].concat([1,2,3].map((t=>i.roro([0,0,1],2*t/5*Math.PI)))).concat([h]).concat([1,2,3,4].map((t=>h.roro([0,0,1],2*t/5*Math.PI)))).concat([[0,0,h[2]-a[2]]]).map((t=>t.add([0,0,-h[2]/2])))}function ico_axis_3(r,e=a,n=s){const[i,c,l]=[r[0].norm(),r[1].norm(),r[2].sub(r[1]).norm()],d=[0,i*(1/o),0],u=[i/2,-i*(o/6),0],h=[-i/2,-i*(o/6),0],m=[0,-i*(2*o/3),0];function fold(t){let[a,s]=[m.uvec().mul(i*(o/2)),u.sub(h).uvec()];const d=[0,-i*(o/6),0].add(a.roro(s,t)),p=d.roro([0,0,1],2/3*Math.PI);t=r[0].angle(r[1]),[a,s]=[d.sub(u).uvec().mul(c),d.cross(u).uvec()];const b=a.roro(s,t),[g,_]=[u.add(b.proj(a)),u.add(b)];[a,s]=[_.sub(g),u.sub(d).uvec()];const f=t=>l-g.add(a.roro(s,t)).sub(p).norm();brackets(f,0,2*Math.PI,e).next().value;t=bisection(f,...brackets(f,0,2*Math.PI,e).next().value,n,e).slice(-1);const y=g.add(a.roro(s,t));return[d,p,y,Math.abs(d[1])-y.sub([0,0,y[2]]).norm()]}const p=Math.PI/180/10;t=0;for(let o=0;o*p<Math.PI/2;o++){t=o*p;try{fold(t);break}catch(w){}}let obj=t=>fold(t).slice(-1)[0];try{t=bisection(obj,...brackets(obj,t,Math.PI/4,e).next().value,n,e).slice(-1)}catch(w){throw new Error("impossible construction!")}const[b,g,_]=fold(t).slice(0,-1);if(Number.isNaN(b[0]))throw new Error("impossible construction!");const y=[0,0,1];t=2*Math.PI/3;const M=_.roro(y,-t),v=M.sub([0,0,M[2]]).roro(y,Math.PI/3).uvec().mul(d[1]).add([0,0,M[2]+b[2]-d[2]]);let P=[d,u,h,b,g.roro(y,t),g,_,M,M.roro(y,-t),v,v.roro(y,-t),v.roro(y,-2*t)];return P.map((t=>t.add([0,0,(P[0][2]-P.slice(-1)[0][2])/2])))}function ico_axis_2(r,o=a,e=s){const[i,c,l]=[r[0].norm(),r[1].norm(),r[2].sub(r[1]).norm()],d=[i/2,0,0],u=[-i/2,0,0],h=[0,-i*n/2,-(i*n-i)/2],m=[0,i*n/2,-(i*n-i)/2];function fold(t){let n=u.add(h).div(2),[a,s]=[n.sub(d),h.sub(u).uvec()];const i=n.add(a.roro(s,t)),m=i.roro([0,0,1],Math.PI);t=r[0].angle(r[1]),[a,s]=[h.sub(d).uvec().mul(c),h.cross(d).uvec()];const p=a.roro(s,t);n=d.add(p.proj(a));const b=d.add(p);[a,s]=[b.sub(n),d.sub(h).uvec()];const f=t=>l-n.add(a.roro(s,t)).sub(m).norm();t=bisection(f,...brackets(f,0,2*Math.PI,o).next().value,e,o).slice(-1);const g=n.add(a.roro(s,t));return[i,m,g,i.sub([0,0,i[2]]).norm()-g.sub([0,0,g[2]]).norm()]}const p=Math.PI/180/10;t=0;for(let n=0;n*p<Math.PI/2;n++){t=n*p;try{fold(t);break}catch(v){}}let obj=t=>fold(t).slice(-1)[0];try{t=bisection(obj,...brackets(obj,t,Math.PI/4,o).next().value,e,o).slice(-1)}catch(v){throw new Error("impossible construction!")}const[b,g,_]=fold(t).slice(0,-1);if(Number.isNaN(b[0]))throw new Error("impossible construction!");obj=t=>d.roro([0,0,1],t).add([0,0,_[2]+b[2]]).sub(g).norm()-c;try{t=bisection(obj,...brackets(obj,0,2*Math.PI,o).next().value,e,o).slice(-1)}catch(v){throw new Error("impossible construction!")}const y=d.roro([0,0,1],t).add([0,0,_[2]+b[2]]),M=y.sub([0,0,y[2]]).uvec().roro([0,0,1],Math.PI/2).mul(m[1]).add([0,0,_[2]+b[2]-m[2]]);return coor=[d,u,h,m,b,g,_,_.roro([0,0,1],Math.PI),M,M.roro([0,0,1],Math.PI),y,y.roro([0,0,1],Math.PI)],coor.map((t=>t.add([0,0,(coor[0][2]-coor.slice(-1)[0][2])/2])))}function model_sa_error(t){const r=ck_vectors(calc_tile(t.t,t.R).basis,t.h,t.k,t.H,t.K),o=[[r[3],r[0]],[r[0],r[1]],[r[1],r[2]]],e=["","",ico_axis_2,ico_axis_3,"",ico_axis_5][t.a](r,a,s),n=ico_config(t.a),i=n.t_id.map((t=>parseInt(t[1]))).reduce(((t,r)=>t<r?r:t)),c=Array.from({length:i}).fill(0);n.t_id.forEach(((t,r)=>c[t[1]-1]+=n.t_rep[r]));const l=o.slice(0,i).map(((t,r)=>[...t[0],0].cross([...t[1],0]).norm()/2*c[r])).sum();return(l-n.v_idx.map((t=>t.map((t=>e[t])))).map(((t,r)=>t[1].sub(t[0]).cross(t[2].sub(t[0])).norm()/2*n.t_rep[r])).sum())/l}function lattice_config(t,r,o,e,n,a){const s=calc_tile(a,n),i=ck_vectors(s.basis,t,r,o,e),c=Array.from(tile_grid(i,s.basis)),l=c.map(s.tile),d=c.filter((t=>t.is_vertex)).map((t=>t.coor)).concat([[0,0]]);return l.flat().forEach((t=>{t.data.offset=t.data.mer+(d.some((r=>[t.position.x,t.position.y].sub(r).norm()<=s.radius))?0:3),t.data.centroid=t.segments.map((t=>t.point)).reduce(((t,r)=>t.add(r))).divide(t.segments.length)})),{tile:s,ck:i,lattice:l}}function calc_facets(t){const r=[[3,0],[0,1],[1,2]].map((r=>[t.ck[r[0]],t.ck[r[1]]])).map((t=>new Path({segments:[[0,0],...t],closed:!0,data:{vectors:[[0,0],...t]}}))),o=r.map((r=>new Group({children:t.lattice.flatMap((t=>t.map((t=>{const o=t.intersect(r,{insert:!1});return o.data.has_centroid=r.contains(o.data.centroid),o.data.centroid_on_vertex=r.segments.map((t=>t.point.getDistance(o.data.centroid))).some((t=>t<1e-5)),o})))).filter((t=>t.segments.length>0)),data:r.data})));return r.forEach((t=>t.remove())),o}function draw_net(t){const[r,o,e,n,a,s]=["h","k","H","K","R","t"].map((r=>t[r])),i=lattice_config(r,o,e,n,a,s),c=i.ck;i.lattice.flat().forEach((r=>r.style.fillColor=t["mer_color_"+r.data.offset]+t["mer_alpha_"+r.data.offset]));const l=calc_facets(i);let d;if(5===t.a){const r=new Group(l.slice(0,2)).rotate(-degrees(c[0].angle([1,0]))).scale(-1,1),o=r.clone().rotate(180),e=o.children[1].children.flatMap((t=>t.segments)).map((t=>t.point)).reduce(((t,r)=>t.y<r.y?t:r));o.position.x+=r.children[0].bounds.right-e.x,o.position.y+=r.children[0].bounds.height,d=new Group({children:Array.from({length:5}).flatMap(((t,e)=>{const[n,a]=[r.clone(),o.clone()];return n.position.x+=e*r.children[0].bounds.width,a.position.x+=e*r.children[0].bounds.width,[n,a]})).flatMap((t=>t.children)),position:view.center,style:{strokeColor:t.line_color+t.line_alpha,strokeWidth:t.line_size,strokeCap:"round",strokeJoin:"round"}}),[r,o].forEach((t=>t.remove()))}else if(3===t.a){const r=c[0].angle([1,0]),o=new Group(l).rotate(-degrees(r)).scale(-1,1),e=l[0].clone().rotate(180);e.position.x+=c[0].norm()/2;const n=[e.bounds.topLeft,e.bounds.topRight,e.bounds.bottomCenter].reduce(((t,r)=>t.add(r))).divide(3),a=e.bounds.topRight.add(new Point([1,0].mul(c[1].norm()).rot(-(Math.PI/3-c[1].angle(c[2]))))),s=e.bounds.topRight.add(new Point([1,0].mul(c[2].norm()).rot(-(Math.PI/3-c[1].angle(c[2])+c[1].angle(c[2]))))),i=new Group([...[1,2,3].map(((t,r)=>o.clone().rotate(120*r,n)))]);i.children.slice(0,-1).forEach((t=>t.children[1].remove()));const u=i.clone().rotate(180);u.bounds.left=Math.min(a.x,s.x),u.bounds.bottom=e.bounds.topRight.y,u.position.y-=u.children[1].children[0].bounds.bottom-a.y,u.children.forEach((t=>i.addChild(t.clone()))),i.position=view.center,d=new Group({children:i.children.flatMap((t=>t.children.flat())),style:{strokeColor:t.line_color+t.line_alpha,strokeWidth:t.line_size,strokeCap:"round",strokeJoin:"round"}}),[e,o,u].forEach((t=>t.remove()))}else{if(2!==t.a)throw new Error("invalid symmetry mode!");{const r=c[0].angle([1,0]),o=new Group(l).rotate(-degrees(r)).rotate(-60).scale(-1,1),e=o.children[1].clone(),n=o.children[0].bounds.topLeft.subtract(o.children[0].bounds.bottomCenter);e.position=e.position.add(n);const a=new Group([o.clone(),o.children[0].clone().rotate(60,o.children[0].bounds.topRight),e.clone()]),s=a.clone().rotate(180,a.children[0].children[0].bounds.topRight);s.position=s.position.add(n.rotate(240));const i=new Group([a.clone(),s.clone()]),u=i.children[0].children[2].children.filter((t=>1===t.data.offset)).flatMap((t=>t.segments.map((t=>t.point)))).filter((t=>Math.abs(t.getDistance(i.children[0].children[1].bounds.bottomLeft)-c[1].norm())<1e-5)).reduce(((t,r)=>t.y<r.y?r:t)),h=i.clone();h.position=h.position.add(i.children[1].children[0].children[0].bounds.bottomRight.subtract(u));const m=new Group([i.clone(),h.clone()]);m.position=view.center;const p=m.children.flatMap((t=>t.children)).flatMap((t=>t.children));d=new Group({children:[...p.filter(((t,r)=>r%3==0)).flatMap((t=>t.children)),...p.filter(((t,r)=>r%3!=0))],style:{strokeColor:t.line_color+t.line_alpha,strokeWidth:t.line_size,strokeCap:"round",strokeJoin:"round"}}),[o,e,a,s,i,h].forEach((t=>t.remove()))}}return l.forEach((t=>t.remove())),i.lattice.forEach((t=>t.forEach((t=>t.remove())))),d}function draw_capsid(t){const[r,o,e,n,c,l]=["h","k","H","K","R","t"].map((r=>t[r])),d=lattice_config(r,o,e,n,c,l);d.lattice.flat().forEach((r=>r.style.fillColor=t["mer_color_"+r.data.offset]+t["mer_alpha_"+r.data.offset]));const u=calc_facets(d),h=ico_config(t.a),m=["","",ico_axis_2,ico_axis_3,"",ico_axis_5][t.a](d.ck,a,s),p=2*Math.PI/t.a,b=r==e&&o==n?r=>spherize(r,m[0].norm(),t.s):r=>cylinderize(r,m,t.a,t.s),g=camera(...[t.θ,t.ψ,t.φ].map(radians));let _=[];for(let a=0,s=0;a<h.t_idx.length;a++){const t=u[h.t_idx[a]-1],r=inv3(T(t.data.vectors.map((t=>t.concat(1))))),o=[0,1,2].map((t=>m[h.v_idx[a][t]]));for(let e=0;e<h.t_rep[a];e++,s++){const n=o.map((t=>t.roro([0,0,1],e*p))),a=mmul(T(n),r),i=t.children.map((t=>{const r=t.segments.map((t=>[t.point.x,t.point.y,1])).map((t=>mmul(a,t.T()).flat())).map((t=>b(t))).map((t=>mmul(g,t.concat(1).T()).flat())),o=mmul(g,b(mmul(a,[t.data.centroid.x,t.data.centroid.y,1].T()).flat()).concat(1).T()).flat();return new Path({segments:r.map((t=>t.slice(0,2))),data:Object.assign({},t.data,{id:s,centroid:o,segments_3D:r,normal:r[1].sub(r[0]).cross(r[2].sub(r[0])).uvec()}),closed:!0,style:t.style})}));_=_.concat(new Group({children:i,data:{type:"facet",centroid:mmul(g,b(n.centroid()).concat(1).T()).flat()}}))}}const y=m.map((t=>mmul(g,t.concat(1).T()).flat()));let M=t.penton_fiber_toggle?h.v_con.map((t=>t.map((t=>y[t])).reduce(((t,r)=>t.add(r)),[0,0,0]).uvec())).map(((r,o)=>[y[o],y[o].add(r.mul(t.fiber_length))])):[];M=M.concat(_.flatMap((t=>t.children)).filter((r=>t["mer_toggle_"+r.data.offset]&&r.data.has_centroid)).map((r=>{const o=r.data.centroid;return[o,o.add(r.data.normal.mul(t.fiber_length))]})));let v=[];M.forEach((t=>{let r=0;for(let o of v)t[0].sub(o[0][0]).norm()<i&&(r=o.push(t));0===r&&v.push([t])})),M=v.map((t=>[t[0][0],t.map((t=>t[1])).reduce(((t,r)=>t.add(r)),[0,0,0]).div(t.length)])).map((t=>new Path.Line({from:t[0],to:t[1],data:{centroid:t[1].mul(2)}})));const P=t.knob_toggle?M.map((r=>new Path.Circle({center:r.segments[1].point,radius:t.knob_size,data:{centroid:r.data.centroid}}))):[];_=_.concat(M).concat(P),_.sort(((t,r)=>t.data.centroid[2]<r.data.centroid[2]));const w=new Group({children:_,position:view.center,style:{strokeColor:t.line_color+t.line_alpha,strokeWidth:t.line_size,strokeCap:"round",strokeJoin:"round"}});return P.forEach((r=>r.style.fillColor=t.knob_color+t.knob_alpha)),M.forEach((r=>{r.style.strokeColor=t.fiber_color+t.fiber_alpha,r.style.strokeWidth=t.fiber_size})),u.forEach((t=>t.remove())),d.lattice.forEach((t=>t.forEach((t=>t.remove())))),w}Array.prototype.mul=function(t){return this.map((r=>r*t))},Array.prototype.div=function(t){return this.map((r=>r/t))},Array.prototype.add=function(t){return this.map(((r,o)=>r+t[o]))},Array.prototype.sub=function(t){return this.map(((r,o)=>r-t[o]))},Array.prototype.dot=function(t){return this.map(((r,o)=>r*t[o])).reduce(((t,r)=>t+r))},Array.prototype.sum=function(t=0){return this.reduce(((t,r)=>t+r),t)},Array.prototype.centroid=function(){return this.reduce(((t,r)=>t.add(r))).div(this.length)},Array.prototype.cross=function(t){return[this[1]*t[2]-this[2]*t[1],this[2]*t[0]-this[0]*t[2],this[0]*t[1]-this[1]*t[0]]},Array.prototype.rot=function(t){const[r,o]=[Math.cos(t),Math.sin(t)];return mmul([[r,-o],[o,r]],this.T()).flat()},Array.prototype.roro=function(t,r){return this.mul(Math.cos(r)).add(t.cross(this).mul(Math.sin(r))).add(t.mul(t.dot(this)).mul(1-Math.cos(r)))},Array.prototype.norm=function(){return Math.sqrt(this.map((t=>t*t)).sum())},Array.prototype.uvec=function(){return this.div(this.norm())},Array.prototype.angle=function(t){return Math.acos(this.dot(t)/(this.norm()*t.norm()))},Array.prototype.proj=function(t){return t.mul(this.dot(t)/t.dot(t))},Array.prototype.T=function(){return this.map((t=>[t]))},Array.prototype.has=function(t){return this.some((r=>r.length===t.length&&r.every(((r,o)=>r===t[o]))))};