<!DOCTYPE html>
<meta charset="UTF-8" />
<html lang="en">
    <head>
        <title>capsid</title>
        <style>
            html {
                background-color: #fdfdfd;
            }
            body {
                font-family: "Lucida Console", "Courier New", monospace;
            }
            canvas {
                height: 250px;
                width: 575px;
                border: 1px solid blue;
            }
        </style>
        <script type="text/javascript" src="js/lib/paper-js/paper-core.min.js"></script>
        <script type="text/javascript" src="js/linalg.js"></script>
        <script type="text/javascript">
            const SQRT3 = Math.sqrt(3);
            const SQRT5 = Math.sqrt(5);
            const PHI = (1 + SQRT5) / 2;

            const DEFAULTS = {
                h: parseInt,
                k: parseInt,
                H: parseInt,
                K: parseInt,
                s: parseInt,
                t: (v) => v,
                R: parseFloat,
                θ: parseFloat,
                ψ: parseFloat,
                φ: parseFloat,
            };

            function radians(x) {
                return (x * Math.PI) / 180;
            }

            function intersect(p, q) {
                let x = p.intersect(q);
                p.remove();
                return x;
            }

            function* grid(ck, basis) {
                const bounds = ck.map((e) => mmul(T(inv2(basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round));
                const [min_i, min_j, max_i, max_j] = [
                    //
                    ...[0, 1].map((_, i) => Math.min(...bounds.map((e) => e[i]))),
                    ...[0, 1].map((_, i) => Math.max(...bounds.map((e) => e[i]))),
                ];
                for (let i = min_i; i < max_i + 1; i++) {
                    for (let j = min_j; j < max_j + 1; j++) {
                        yield { index: [i, j], coor: basis[0].mul(i).add(basis[1].mul(j)) };
                    }
                }
            }

            function ck_vectors(basis, h, k, H, K, R = 1) {
                const [v1, v2] = basis;
                const v3 = v2.rot(Math.PI / 3);
                return [
                    //
                    v1.mul(h).add(v2.mul(k)),
                    v2.mul(H).add(v3.mul(K)),
                    v1.mul(-h - k).add(v2.mul(h)),
                    v1.mul(k).add(v3.mul(-h)),
                ];
            }

            function ico_config(s) {
                if (s == 2) {
                    return [
                        [1, 1, 1, 1, 2, 2, 2, 2, 3, 3],
                        ["T1-▔", "T1-▔", "T1▁", "T1▁", "T2-▼", "T2-▲", "T2-▼", "T2-▲", "T3-▼", "T3-▲"],
                        [
                            [0, 1, 2],
                            [2, 1, 4],
                            [9, 10, 6],
                            [9, 11, 10],
                            [0, 2, 6],
                            [9, 6, 2],
                            [2, 4, 9],
                            [9, 11, 4],
                            [0, 6, 5],
                            [10, 5, 6],
                        ],
                    ];
                } else if (s == 3) {
                    return [
                        [1, 1, 1, 1, 2, 2, 3, 3],
                        ["T1-▔", "T1-▲", "T1-▼", "T1-▁", "T2-▼", "T2-▲", "T3-▼", "T3-▲"],
                        [
                            [0, 2, 1],
                            [1, 2, 3],
                            [6, 11, 9],
                            [9, 11, 10],
                            [1, 3, 6],
                            [9, 6, 3],
                            [1, 6, 5],
                            [11, 5, 6],
                        ],
                    ];
                } else if (s == 5) {
                    return [
                        [1, 1, 2, 2],
                        ["T1-▲", "T1-▼", "T2-▲", "T2-▼"],
                        [
                            [0, 1, 2],
                            [6, 11, 7],
                            [2, 1, 6],
                            [6, 7, 2],
                        ],
                    ];
                } else {
                    throw new Error("s must be 2, 3, or 5");
                }
            }

            function ico_axis_5(ck, iter = 0, tol = 0) {
                const a = ck[0].norm();
                const b = ck[1].norm();

                // regular pentagon circumradius
                const R5 = a * Math.sqrt((5 + SQRT5) / 10);
                // regular pentagonal pyramid height
                const h5 = ((1 + SQRT5) * a) / (2 * Math.sqrt(5 + 2 * SQRT5));

                const pA = [0, 0, h5];
                const pB = [-R5, 0, 0].roro([0, 0, 1], (3 / 10) * Math.PI); // 54°
                const pC = pB.add([a, 0, 0]);

                const t = ck[0].angle(ck[1]);
                const q = pC.add([b, 0, 0].roro([0, 1, 0], -Math.PI - t));
                const p = pB.add(q.sub(pB).proj(pC.sub(pB)));
                const d = [p[0], (-Math.abs(p[1]) * Math.sqrt(R5 * R5 * p[1] * p[1] - (p[0] * p[1]) ** 2)) / (p[1] * p[1]), 0];

                const pG = d.add([0, 0, -Math.sqrt(q[2] * q[2] - (p[1] - d[1]) ** 2)]);
                const coor = [pA, pB, pC]
                    .concat([1, 2, 3].map((e) => pC.roro([0, 0, 1], ((e * 2) / 5) * Math.PI)))
                    .concat([pG])
                    .concat([1, 2, 3, 4].map((e) => pG.roro([0, 0, 1], ((e * 2) / 5) * Math.PI)))
                    .concat([[0, 0, pG[2] - pA[2]]]);

                return coor.map((e) => e.add([0, 0, -pG[2] / 2]));
            }

            function ico_axis_3(ck, iter = 100, tol = 1e-15) {
                const a = ck[0].norm();
                const b = ck[1].norm();
                const c = ck[2].sub(ck[1]).norm();

                const pA = [0, a * (1 / SQRT3), 0];
                const pB = [a / 2, -(a * (SQRT3 / 6)), 0];
                const pC = [-(a / 2), -(a * (SQRT3 / 6)), 0];
                const qD = [0, -(a * ((2 * SQRT3) / 3)), 0];
                const qF = [a, a / SQRT3, 0];

                function fold(t) {
                    let [v, k] = [qD.uvec().mul(a * (SQRT3 / 2)), pB.sub(pC).uvec()];
                    const pD = [0, -(a * (SQRT3 / 6)), 0].add(v.roro(k, t));
                    const pF = pD.roro([0, 0, 1], (2 / 3) * Math.PI);
                    t = ck[0].angle(ck[1]);
                    [v, k] = [pD.sub(pB).uvec().mul(b), pD.cross(pB).uvec()];
                    const o = v.roro(k, t);
                    const [p, q] = [pB.add(o.proj(v)), pB.add(o)];
                    [v, k] = [q.sub(p), pB.sub(pD).uvec()];
                    // f = lambda t: c - np.linalg.norm((p + roro(v, k, t)) - pF)
                    const f = (t) => c - p.add(v.roro(k, t)).sub(pF).norm();
                    let br = brackets(f, 0, 2 * Math.PI, iter).next().value;
                    // t = bisect_brackets(f, 0, 2 * Math.PI, tol, iter).next().value[2];
                    t = bisection(f, ...brackets(f, 0, 2 * Math.PI, iter).next().value, tol, iter).slice(-1);
                    // for (let [a, b] of brackets(f, 0, 2 * Math.PI, iter)) {
                    //     t = bisection(f, a, b, tol, iter);
                    //     break;
                    // }
                    const pG = p.add(v.roro(k, t));
                    return [pD, pF, pG, Math.abs(pD[1]) - pG.sub([0, 0, pG[2]]).norm()];
                }

                const delta = Math.PI / 180 / 10;
                t = 0;
                for (let i = 0; i * delta < Math.PI / 2; i++) {
                    t = i * delta;
                    try {
                        fold(t);
                        break;
                    } catch (e) {}
                }
                let obj = (t) => fold(t).slice(-1)[0];
                t = bisection(obj, ...brackets(obj, t, Math.PI / 4, iter).next().value, tol, iter).slice(-1);

                const [pD, pF, pG] = fold(t).slice(0, -1);
                const k = [0, 0, 1];
                t = (2 * Math.PI) / 3;
                const pH = pG.roro(k, -t);
                const pJ = pH
                    .sub([0, 0, pH[2]])
                    .roro(k, Math.PI / 3)
                    .uvec()
                    .mul(pA[1])
                    .add([0, 0, pH[2] + pD[2] - pA[2]]);

                let coor = [pA, pB, pC, pD, pF.roro(k, t), pF, pG, pH, pH.roro(k, -t), pJ, pJ.roro(k, -t), pJ.roro(k, -2 * t)];
                return coor.map((e) => e.add([0, 0, (coor[0][2] - coor.slice(-1)[0][2]) / 2]));
            }

            function ico_axis_2(ck, iter = 100, tol = 1e-15) {
                const a = ck[0].norm();
                const b = ck[1].norm();
                const c = ck[2].sub(ck[1]).norm();

                const pA = [a / 2, 0, 0];
                const pB = [-(a / 2), 0, 0];
                const pC = [0, -((a * PHI) / 2), -((a * PHI - a) / 2)];
                const pD = [0, (a * PHI) / 2, -((a * PHI - a) / 2)];

                function fold(t) {
                    let p = pB.add(pC).div(2);
                    let [v, k] = [p.sub(pA), pC.sub(pB).uvec()];
                    const pE = p.add(v.roro(k, t));
                    const pF = pE.roro([0, 0, 1], Math.PI);

                    t = ck[0].angle(ck[1]);
                    [v, k] = [pC.sub(pA).uvec().mul(b), pC.cross(pA).uvec()];
                    const o = v.roro(k, t);
                    p = pA.add(o.proj(v));
                    const q = pA.add(o);
                    [v, k] = [q.sub(p), pA.sub(pC).uvec()];
                    const f = (t) => c - p.add(v.roro(k, t)).sub(pF).norm();
                    t = bisection(f, ...brackets(f, 0, 2 * Math.PI, iter).next().value, tol, iter).slice(-1);
                    const pG = p.add(v.roro(k, t));

                    return [pE, pF, pG, pE.sub([0, 0, pE[2]]).norm() - pG.sub([0, 0, pG[2]]).norm()];
                }

                const delta = Math.PI / 180 / 10;
                t = 0;
                for (let i = 0; i * delta < Math.PI / 2; i++) {
                    t = i * delta;
                    try {
                        fold(t);
                        break;
                    } catch (e) {}
                }
                let obj = (t) => fold(t).slice(-1)[0];
                t = bisection(obj, ...brackets(obj, t, Math.PI / 4, iter).next().value, tol, iter).slice(-1);
                const [pE, pF, pG] = fold(t).slice(0, -1);

                // function obj(t){
                //     pK = roro(pA, np.array([0, 0, 1]), t) + np.array([0, 0, pG[2] + pE[2]])
                //     return np.linalg.norm(pK - pF) - b
                // }
                obj = (t) =>
                    pA
                        .roro([0, 0, 1], t)
                        .add([0, 0, pG[2] + pE[2]])
                        .sub(pF)
                        .norm() - b;
                // t = next(bisection(obj, a, b, tol=tol, iter=iter)[2] for a, b in brackets(obj, 0, 2 * np.pi, iter))
                t = bisection(obj, ...brackets(obj, 0, 2 * Math.PI, iter).next().value, tol, iter).slice(-1);
                const pK = pA.roro([0, 0, 1], t).add([0, 0, pG[2] + pE[2]]);
                const pI = pK
                    .sub([0, 0, pK[2]])
                    .uvec()
                    .roro([0, 0, 1], Math.PI / 2)
                    .mul(pD[1])
                    .add([0, 0, pG[2] + pE[2] - pD[2]]);

                coor = [pA, pB, pC, pD, pE, pF, pG, pG.roro([0, 0, 1], Math.PI), pI, pI.roro([0, 0, 1], Math.PI), pK, pK.roro([0, 0, 1], Math.PI)];

                return coor.map((e) => e.add([0, 0, (coor[0][2] - coor.slice(-1)[0][2]) / 2]));
            }

            function params() {
                return Object.fromEntries(Object.keys(DEFAULTS).map((k) => [k, DEFAULTS[k](document.getElementById(k).value)]));
            }

            function calc_tile_basis(t, R) {
                const r = R * (SQRT3 / 2);
                if (t == "hex")
                    basis = [
                        [2 * r, 0],
                        [r, SQRT3 * r],
                    ];
                else if (t == "trihex")
                    basis = [
                        [2 * R, 0],
                        [R, R * SQRT3],
                    ];
                else if (t == "snubhex")
                    basis = [
                        [2.5 * R, r],
                        [0.5 * R, 3 * r],
                    ];
                else if (t == "rhombitrihex")
                    basis = [
                        [R + r + 0.5 * R, 0.5 * R + r],
                        [0, 2 * r + R],
                    ];
                else if (t == "dualhex")
                    basis = [
                        [(3 / 2) * R, r],
                        [0, 2 * r],
                    ];
                else if (t == "dualtrihex")
                    basis = [
                        [2 * r, 0],
                        [r, SQRT3 * r],
                    ];
                else if (t == "dualrhombitrihex") {
                    basis = [
                        [(3 / 2) * R, r],
                        [0, 2 * r],
                    ];
                } else throw new Error("incorrect tile mode");
                return basis;
            }

            function calc_tile_func(t, R, bounds) {
                let tile;
                const r = R * (SQRT3 / 2);
                const fillColor = (e) => (bounds.some((v) => v.every((u, i) => u == e.index[i])) ? "black" : "white");
                if (t == "hex")
                    tile = (e) => [
                        new Path.RegularPolygon({
                            center: e.coor,
                            fillColor: fillColor(e),
                            sides: 6,
                            radius: R,
                            strokeColor: "black",
                            strokeWidth: 2,
                            strokeCap: "round",
                            strokeJoin: "round",
                            data: { type: "hex-1" },
                        }),
                    ];
                else if (t == "trihex")
                    tile = (e) => [
                        new Path.RegularPolygon({
                            center: e.coor,
                            fillColor: fillColor(e),
                            sides: 6,
                            radius: R,
                            data: { type: "hex-1" },
                        }).rotate(30),
                        ...Array.from({ length: 2 }, (_, i) =>
                            new Path.RegularPolygon({
                                center: e.coor.add([R, -(1 / 3) * r]),
                                fillColor: "white",
                                sides: 3,
                                radius: (2 / 3) * r,
                                data: { type: "hex-2" },
                            })
                                .rotate(180)
                                .rotate(i * 60, e.coor)
                        ),
                    ];
                else if (t == "snubhex")
                    tile = (e) => [
                        new Path.RegularPolygon({
                            center: e.coor,
                            fillColor: fillColor(e),
                            sides: 6,
                            radius: R,
                            data: { type: "hex-1" },
                        }).rotate(30),
                        ...Array.from({ length: 6 }, (_, i) =>
                            new Path.RegularPolygon({
                                center: e.coor.add([0, -r - (1 / 3) * r]),
                                fillColor: fillColor(e),
                                sides: 3,
                                radius: (2 / 3) * r,
                                data: { type: "hex-2" },
                            }).rotate(i * 60, e.coor)
                        ),
                        new Path.RegularPolygon({
                            center: e.coor.add([1.5 * R, -(1 / 3) * r]),
                            fillColor: "white",
                            sides: 3,
                            radius: (2 / 3) * r,
                            data: { type: "hex-2" },
                        }),
                        new Path.RegularPolygon({
                            center: e.coor.add([-1.5 * R, (2 / 3) * r]),
                            fillColor: "white",
                            sides: 3,
                            radius: (2 / 3) * r,
                            data: { type: "hex-2" },
                        }).rotate(180),
                    ];
                else if (t == "rhombitrihex")
                    tile = (e) => [
                        new Path.RegularPolygon({
                            center: e.coor,
                            fillColor: fillColor(e),
                            sides: 6,
                            radius: R,
                            data: { type: "hex-1" },
                        }).rotate(30),
                        ...Array.from({ length: 3 }, (_, i) =>
                            new Path.RegularPolygon({
                                center: e.coor.add([0, -r - 0.5 * R]),
                                fillColor: "white",
                                sides: 4,
                                radius: Math.sqrt(2 * R * R) / 2,
                            }).rotate(i * 60, e.coor)
                        ),
                        ...Array.from({ length: 3 }, (_, i) =>
                            new Path.RegularPolygon({
                                center: e.coor.add([0, R + R * (SQRT3 / 3)]),
                                fillColor: "white",
                                sides: 3,
                                radius: R / SQRT3,
                            }).rotate(-30 + i * -60, e.coor)
                        ),
                    ];
                else if (t == "dualhex")
                    tile = (e) =>
                        Array.from({ length: 6 }, (_, i) =>
                            new Path.RegularPolygon({
                                center: e.coor.add([0, r - (R * SQRT3) / 6]),
                                fillColor: "white",
                                sides: 3,
                                radius: R / SQRT3,
                            }).rotate(i * 60, e.coor)
                        );
                else if (t == "dualtrihex")
                    tile = (e) => [
                        ...Array.from({ length: 6 }, (_, i) =>
                            new Path({
                                segments: [
                                    [0, 0],
                                    [0.5 * r, -(0.25 * R * Math.sin(Math.PI / 6)) / Math.cos(Math.PI / 3)],
                                    [r, 0],
                                    [0.5 * r, (0.25 * R * Math.sin(Math.PI / 6)) / Math.cos(Math.PI / 3)],
                                ].map((f) => e.coor.add(f)),
                                closed: true,
                                fillColor: fillColor(e),
                            }).rotate(i * 60, e.coor)
                        ),
                        ...Array.from({ length: 6 }, (_, i) =>
                            new Path({
                                segments: [
                                    [-0.5 * r, R + (0.25 * R * Math.sin(Math.PI / 6)) / Math.cos(Math.PI / 3)],
                                    [0, R],
                                    [r - 0.5 * r, R + (0.25 * R * Math.sin(Math.PI / 6)) / Math.cos(Math.PI / 3)],
                                    [0, R + (2 * (0.25 * R * Math.sin(Math.PI / 6))) / Math.cos(Math.PI / 3)],
                                ].map((f) => e.coor.add(f)),
                                closed: true,
                                fillColor: "white",
                            }).rotate(i * 60, e.coor)
                        ),
                    ];
                else if (t == "dualsnubhex");
                else if (t == "dualrhombitrihex")
                    tile = (e) =>
                        Array.from({ length: 6 }, (_, i) =>
                            new Path({
                                segments: [
                                    [0, 0],
                                    [0, r],
                                    [0.5 * R, r],
                                    [(SQRT3 / 2) * r, 0.5 * r],
                                ].map((f) => e.coor.add(f)),
                                closed: true,
                                fillColor: fillColor(e),
                            }).rotate(i * 60, e.coor)
                        );
                else throw new Error("incorrect tile mode");
                return tile;
            }

            function draw1() {
                const PARAMS = params();
                const r = PARAMS.R * (SQRT3 / 2);
                const basis = calc_tile_basis(PARAMS.t, PARAMS.R);
                const ck = ck_vectors(basis, PARAMS.h, PARAMS.k, PARAMS.H, PARAMS.K);
                const bounds = [[0, 0]].concat(ck.map((e) => mmul(T(inv2(basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round)));

                let lattice = Array.from(grid(ck, basis)).map(calc_tile_func(PARAMS.t, PARAMS.R, bounds));
                let triangles = [
                    [ck[3], ck[0]],
                    [ck[0], ck[1]],
                    [ck[1], ck[2]],
                ].map((e) => new Path({ segments: [[0, 0], ...e], strokeWidth: 4, strokeColor: "black", closed: true, data: { vectors: [[0, 0], ...e] } }));

                new Group({
                    children: triangles.map((e) => new Group(lattice.flatMap((f) => f.map((g) => g.intersect(e))).filter((e) => e.segments.length > 0))).concat(triangles),
                    position: view.center,
                    strokeColor: "black",
                    strokeWidth: 2,
                    strokeCap: "round",
                    strokeJoin: "round",
                });
                lattice.forEach((e) => e.forEach((f) => f.remove()));
                // triangles.forEach((e) => e.remove());
            }

            function draw2() {
                const PARAMS = params();
                const r = PARAMS.R * (SQRT3 / 2);
                const basis = calc_tile_basis(PARAMS.t, PARAMS.R);
                const ck = ck_vectors(basis, PARAMS.h, PARAMS.k, PARAMS.H, PARAMS.K);
                const bounds = [[0, 0]].concat(ck.map((e) => mmul(T(inv2(basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round)));

                let lattice = Array.from(grid(ck, basis)).map(calc_tile_func(PARAMS.t, PARAMS.R, bounds));
                let triangles = [
                    [ck[3], ck[0]],
                    [ck[0], ck[1]],
                    [ck[1], ck[2]],
                ]
                    .map((e) => new Path({ segments: [[0, 0], ...e], strokeWidth: 4, strokeColor: "black", closed: true, data: { vectors: [[0, 0], ...e] } }))
                    .map((e) => new Group({ children: lattice.flatMap((f) => f.map((g) => g.intersect(e))).filter((e) => e.segments.length > 0), data: e.data }));

                const CAMERA = camera(...[PARAMS.θ, PARAMS.ψ, PARAMS.φ].map(radians));
                const AXIS = mmul(CAMERA, [0, 0, 1, 1].T());
                let ico_axis = ["", ico_axis_2, ico_axis_3, "", ico_axis_5][PARAMS.s - 1];
                let coors = ico_axis(ck).map((e) => mmul(CAMERA, e.concat(1).T()).flat());
                let [t_idx, t_id, v_idx] = ico_config(PARAMS.s);
                const th = (2 * Math.PI) / PARAMS.s;

                let results = [];
                for (let idx = 0; idx < t_idx.length; idx++) {
                    let triangle = triangles[t_idx[idx] - 1];
                    let A = T(triangle.data.vectors.map((e) => e.concat(1)));
                    let V = [0, 1, 2].map((e) => coors[v_idx[idx][e]]);
                    for (let i = 0; i < 5; i++) {
                        let X = V.map((e) => e.roro(AXIS, i * th));
                        let centroid = X.reduce((a, b) => a.add(b)).div(X.length);
                        let M = mmul([...T(X).slice(0, 2), [1, 1, 1]], inv3(A));
                        let face = triangle.clone().transform(new paper.Matrix(M[0][0], M[1][0], M[0][1], M[1][1], M[0][2], M[1][2]));
                        face.data.centroid = centroid;
                        results.push(face);
                    }
                }
                results.sort((a, b) => a.data.centroid[2] < b.data.centroid[2]);
                new Group({
                    children: results,
                    position: view.center,
                    style: { strokeColor: "black", strokeCap: "round", strokeJoin: "round" },
                });

                triangles.forEach((e) => e.remove());
                lattice.forEach((e) => e.forEach((f) => f.remove()));
            }

            function update(e) {
                paper.clear();
                paper.setup("canvas1");
                draw1();
                paper.setup("canvas2");
                draw2();
            }

            paper.install(window);

            window.onload = function (opt) {
                Object.keys(DEFAULTS).forEach((e) => document.getElementById(e).addEventListener("change", update));
                update();
            };
        </script>
    </head>
    <body>
        <div>
            <label for="h">h&nbsp;=&nbsp;</label>
            <input type="number" id="h" step="1" value="1" min="0" />
            <label for="k">k&nbsp;=&nbsp;</label>
            <input type="number" id="k" step="1" value="1" min="0" />
            <label for="H">H&nbsp;=&nbsp;</label>
            <input type="number" id="H" step="1" value="1" min="0" />
            <label for="K">K&nbsp;=&nbsp;</label>
            <input type="number" id="K" step="1" value="2" min="0" />
            <div>
                <label for="s">S&nbsp;=&nbsp;</label>
                <select id="s">
                    <option value="5">5</option>
                    <option value="3">3</option>
                    <option value="2">2</option>
                </select>
                <label for="t">t&nbsp;=&nbsp;</label>
                <select id="t">
                    <option value="hex">hex</option>
                    <option value="trihex">trihex</option>
                    <option value="snubhex">snubhex</option>
                    <option value="rhombitrihex">rhombitrihex</option>
                    <option value="dualhex">dualhex</option>
                    <option value="dualtrihex">dualtrihex</option>
                    <option value="dualsnubhex">dualsnubhex</option>
                    <option value="dualrhombitrihex">dualrhombitrihex</option>
                </select>
            </div>
            <div>
                <label for="R">R&nbsp;=&nbsp;</label>
                <input type="number" id="R" step="1" value="10" min="1" />
            </div>
        </div>
        <div>
            <label for="θ">θ&nbsp;=&nbsp;</label>
            <input type="number" id="θ" step="10" value="0" min="0" />
            <label for="ψ">ψ&nbsp;=&nbsp;</label>
            <input type="number" id="ψ" step="10" value="0" min="0" />
            <label for="φ">φ&nbsp;=&nbsp;</label>
            <input type="number" id="φ" step="10" value="0" min="0" />
        </div>
        <br />
        <div>
            <canvas id="canvas1" resize> Your browser does not support the HTML canvas tag. </canvas>
            <canvas id="canvas2" resize> Your browser does not support the HTML canvas tag. </canvas>
        </div>
    </body>
</html>
