<!DOCTYPE html>
<meta charset="UTF-8" />
<html lang="en">
    <head>
        <title>capsid</title>
        <style>
            html {
                background-color: #fdfdfd;
            }
            body {
                font-family: "Lucida Console", "Courier New", monospace;
            }
            canvas {
                height: 300px;
                width: 600px;
                border: 4px solid blue;
            }
            input,
            select {
                box-sizing: border-box;
                vertical-align: middle;
                height: 30px;
                width: 150px;
            }
            table,
            th,
            td {
                border: 1px solid black;
                text-align: center;
            }
            th:first-child,
            td:first-child {
                width: 100px;
            }
            th:not(:first-child),
            td:not(:first-child) {
                width: 125px;
            }
            td > input {
                width: 100px;
            }
        </style>
        <script type="text/javascript" src="js/lib/paper-js/paper-core.min.js"></script>
        <script type="text/javascript" src="js/linalg.js"></script>
        <script type="text/javascript">
            const SQRT3 = Math.sqrt(3);
            const SQRT5 = Math.sqrt(5);
            const PHI = (1 + SQRT5) / 2;

            const PARSERS = {
                color: (e) => e.value,
                alpha: (e) => Number(e.value).toString(16).padStart(2, "0"),
                toggle: (e) => e.checked,
                width: (e) => parseFloat(e.value),
                length: (e) => parseFloat(e.value),
            };

            const DEFAULTS = Object.assign(
                {},
                {
                    h: (e) => parseInt(e.value),
                    k: (e) => parseInt(e.value),
                    H: (e) => parseInt(e.value),
                    K: (e) => parseInt(e.value),
                    s: (e) => parseInt(e.value),
                    t: (e) => e.value,
                    R: (e) => parseFloat(e.value),
                    θ: (e) => parseFloat(e.value),
                    ψ: (e) => parseFloat(e.value),
                    φ: (e) => parseFloat(e.value),
                    penton_fiber_toggle: (e) => e.checked,
                    hexon_fiber_toggle: (e) => e.checked,
                },
                Object.fromEntries([
                    ...["color", "alpha", "width"].map((e) => ["line_" + e, PARSERS[e]]),
                    ...["color", "alpha", "width", "length"].map((e) => ["fiber_" + e, PARSERS[e]]),
                    ...["color", "alpha", "toggle"].flatMap((e) => Array.from({ length: 6 }, (_, i) => ["mer_" + e + "_" + (i + 1), PARSERS[e]])),
                ])
            );

            function radians(x) {
                return (x * Math.PI) / 180;
            }

            function* grid(ck, basis) {
                const bounds = ck.map((e) => mmul(T(inv2(basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round));
                const [min_i, min_j, max_i, max_j] = [
                    //
                    ...[0, 1].map((_, i) => Math.min(...bounds.map((e) => e[i]))),
                    ...[0, 1].map((_, i) => Math.max(...bounds.map((e) => e[i]))),
                ];
                for (let i = min_i; i < max_i + 1; i++) {
                    for (let j = min_j; j < max_j + 1; j++) {
                        yield { index: [i, j], coor: basis[0].mul(i).add(basis[1].mul(j)), is_vertex: bounds.has([i, j]) };
                    }
                }
            }

            function ck_vectors(basis, h, k, H, K, R = 1) {
                const [v1, v2] = basis;
                const v3 = v2.rot(Math.PI / 3);
                return [
                    //
                    v1.mul(h).add(v2.mul(k)),
                    v2.mul(H).add(v3.mul(K)),
                    v1.mul(-h - k).add(v2.mul(h)),
                    v1.mul(k).add(v3.mul(-h)),
                ];
            }

            function ico_config(s) {
                if (s == 2) {
                    return [
                        [1, 1, 1, 1, 2, 2, 2, 2, 3, 3],
                        ["T1-▔", "T1-▔", "T1▁", "T1▁", "T2-▼", "T2-▲", "T2-▼", "T2-▲", "T3-▼", "T3-▲"],
                        [
                            [0, 1, 2],
                            [2, 1, 4],
                            [9, 10, 6],
                            [9, 11, 10],
                            [0, 2, 6],
                            [9, 6, 2],
                            [2, 4, 9],
                            [9, 11, 4],
                            [0, 6, 5],
                            [10, 5, 6],
                        ],
                        [2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
                        [
                            [1, 2, 3, 5, 6],
                            [0, 2, 3, 4, 7],
                            [0, 1, 4, 6, 9],
                            [0, 1, 5, 7, 8],
                            [1, 2, 7, 9, 11],
                            [0, 3, 6, 8, 10],
                            [0, 2, 5, 9, 10],
                            [1, 3, 4, 8, 11],
                            [3, 5, 7, 10, 11],
                            [2, 4, 6, 10, 11],
                            [5, 6, 8, 9, 11],
                            [4, 7, 8, 9, 10],
                        ],
                    ];
                } else if (s == 3) {
                    return [
                        [1, 1, 1, 1, 2, 2, 3, 3],
                        ["T1-▔", "T1-▲", "T1-▼", "T1-▁", "T2-▼", "T2-▲", "T3-▼", "T3-▲"],
                        [
                            [0, 2, 1],
                            [1, 2, 3],
                            [6, 11, 9],
                            [9, 11, 10],
                            [1, 3, 6],
                            [9, 6, 3],
                            [1, 6, 5],
                            [11, 5, 6],
                        ],
                        [1, 3, 3, 1, 3, 3, 3, 3],
                        [
                            [1, 2, 3, 4, 5],
                            [0, 2, 5, 6, 10],
                            [0, 1, 3, 6, 7],
                            [0, 2, 4, 7, 8],
                            [0, 3, 5, 8, 9],
                            [0, 1, 4, 9, 10],
                            [1, 2, 7, 10, 11],
                            [2, 3, 6, 8, 11],
                            [3, 4, 7, 9, 11],
                            [4, 5, 8, 10, 11],
                            [1, 5, 6, 9, 11],
                            [6, 7, 8, 9, 10],
                        ],
                    ];
                } else if (s == 5) {
                    return [
                        [1, 1, 2, 2],
                        ["T1-▲", "T1-▼", "T2-▲", "T2-▼"],
                        [
                            [0, 1, 2],
                            [6, 11, 7],
                            [2, 1, 6],
                            [6, 7, 2],
                        ],
                        [5, 5, 5, 5],
                        [
                            [1, 2, 3, 4, 5],
                            [0, 2, 5, 6, 10],
                            [0, 1, 3, 6, 7],
                            [0, 2, 4, 7, 8],
                            [0, 3, 5, 8, 9],
                            [0, 1, 4, 9, 10],
                            [1, 2, 7, 10, 11],
                            [2, 3, 6, 8, 11],
                            [3, 4, 7, 9, 11],
                            [4, 5, 8, 10, 11],
                            [1, 5, 6, 9, 11],
                            [6, 7, 8, 9, 10],
                        ],
                    ];
                } else {
                    throw new Error("s must be 2, 3, or 5");
                }
            }

            function ico_axis_5(ck, iter = 0, tol = 0) {
                const a = ck[0].norm();
                const b = ck[1].norm();

                // regular pentagon circumradius
                const R5 = a * Math.sqrt((5 + SQRT5) / 10);
                // regular pentagonal pyramid height
                const h5 = ((1 + SQRT5) * a) / (2 * Math.sqrt(5 + 2 * SQRT5));

                const pA = [0, 0, h5];
                const pB = [-R5, 0, 0].roro([0, 0, 1], (3 / 10) * Math.PI); // 54°
                const pC = pB.add([a, 0, 0]);

                const t = ck[0].angle(ck[1]);
                const q = pC.add([b, 0, 0].roro([0, 1, 0], -Math.PI - t));
                const p = pB.add(q.sub(pB).proj(pC.sub(pB)));
                const d = [p[0], (-Math.abs(p[1]) * Math.sqrt(R5 * R5 * p[1] * p[1] - (p[0] * p[1]) ** 2)) / (p[1] * p[1]), 0];

                const pG = d.add([0, 0, -Math.sqrt(q[2] * q[2] - (p[1] - d[1]) ** 2)]);
                const coor = [pA, pB, pC]
                    .concat([1, 2, 3].map((e) => pC.roro([0, 0, 1], ((e * 2) / 5) * Math.PI)))
                    .concat([pG])
                    .concat([1, 2, 3, 4].map((e) => pG.roro([0, 0, 1], ((e * 2) / 5) * Math.PI)))
                    .concat([[0, 0, pG[2] - pA[2]]]);

                return coor.map((e) => e.add([0, 0, -pG[2] / 2]));
            }

            function ico_axis_3(ck, iter = 100, tol = 1e-15) {
                const a = ck[0].norm();
                const b = ck[1].norm();
                const c = ck[2].sub(ck[1]).norm();

                const pA = [0, a * (1 / SQRT3), 0];
                const pB = [a / 2, -(a * (SQRT3 / 6)), 0];
                const pC = [-(a / 2), -(a * (SQRT3 / 6)), 0];
                const qD = [0, -(a * ((2 * SQRT3) / 3)), 0];
                const qF = [a, a / SQRT3, 0];

                function fold(t) {
                    let [v, k] = [qD.uvec().mul(a * (SQRT3 / 2)), pB.sub(pC).uvec()];
                    const pD = [0, -(a * (SQRT3 / 6)), 0].add(v.roro(k, t));
                    const pF = pD.roro([0, 0, 1], (2 / 3) * Math.PI);
                    t = ck[0].angle(ck[1]);
                    [v, k] = [pD.sub(pB).uvec().mul(b), pD.cross(pB).uvec()];
                    const o = v.roro(k, t);
                    const [p, q] = [pB.add(o.proj(v)), pB.add(o)];
                    [v, k] = [q.sub(p), pB.sub(pD).uvec()];
                    // f = lambda t: c - np.linalg.norm((p + roro(v, k, t)) - pF)
                    const f = (t) => c - p.add(v.roro(k, t)).sub(pF).norm();
                    let br = brackets(f, 0, 2 * Math.PI, iter).next().value;
                    // t = bisect_brackets(f, 0, 2 * Math.PI, tol, iter).next().value[2];
                    t = bisection(f, ...brackets(f, 0, 2 * Math.PI, iter).next().value, tol, iter).slice(-1);
                    // for (let [a, b] of brackets(f, 0, 2 * Math.PI, iter)) {
                    //     t = bisection(f, a, b, tol, iter);
                    //     break;
                    // }
                    const pG = p.add(v.roro(k, t));
                    return [pD, pF, pG, Math.abs(pD[1]) - pG.sub([0, 0, pG[2]]).norm()];
                }

                const delta = Math.PI / 180 / 10;
                t = 0;
                for (let i = 0; i * delta < Math.PI / 2; i++) {
                    t = i * delta;
                    try {
                        fold(t);
                        break;
                    } catch (e) {}
                }
                let obj = (t) => fold(t).slice(-1)[0];
                t = bisection(obj, ...brackets(obj, t, Math.PI / 4, iter).next().value, tol, iter).slice(-1);

                const [pD, pF, pG] = fold(t).slice(0, -1);
                const k = [0, 0, 1];
                t = (2 * Math.PI) / 3;
                const pH = pG.roro(k, -t);
                const pJ = pH
                    .sub([0, 0, pH[2]])
                    .roro(k, Math.PI / 3)
                    .uvec()
                    .mul(pA[1])
                    .add([0, 0, pH[2] + pD[2] - pA[2]]);

                let coor = [pA, pB, pC, pD, pF.roro(k, t), pF, pG, pH, pH.roro(k, -t), pJ, pJ.roro(k, -t), pJ.roro(k, -2 * t)];
                return coor.map((e) => e.add([0, 0, (coor[0][2] - coor.slice(-1)[0][2]) / 2]));
            }

            function ico_axis_2(ck, iter = 100, tol = 1e-15) {
                const a = ck[0].norm();
                const b = ck[1].norm();
                const c = ck[2].sub(ck[1]).norm();

                const pA = [a / 2, 0, 0];
                const pB = [-(a / 2), 0, 0];
                const pC = [0, -((a * PHI) / 2), -((a * PHI - a) / 2)];
                const pD = [0, (a * PHI) / 2, -((a * PHI - a) / 2)];

                function fold(t) {
                    let p = pB.add(pC).div(2);
                    let [v, k] = [p.sub(pA), pC.sub(pB).uvec()];
                    const pE = p.add(v.roro(k, t));
                    const pF = pE.roro([0, 0, 1], Math.PI);

                    t = ck[0].angle(ck[1]);
                    [v, k] = [pC.sub(pA).uvec().mul(b), pC.cross(pA).uvec()];
                    const o = v.roro(k, t);
                    p = pA.add(o.proj(v));
                    const q = pA.add(o);
                    [v, k] = [q.sub(p), pA.sub(pC).uvec()];
                    const f = (t) => c - p.add(v.roro(k, t)).sub(pF).norm();
                    t = bisection(f, ...brackets(f, 0, 2 * Math.PI, iter).next().value, tol, iter).slice(-1);
                    const pG = p.add(v.roro(k, t));

                    return [pE, pF, pG, pE.sub([0, 0, pE[2]]).norm() - pG.sub([0, 0, pG[2]]).norm()];
                }

                const delta = Math.PI / 180 / 10;
                t = 0;
                for (let i = 0; i * delta < Math.PI / 2; i++) {
                    t = i * delta;
                    try {
                        fold(t);
                        break;
                    } catch (e) {}
                }
                let obj = (t) => fold(t).slice(-1)[0];
                t = bisection(obj, ...brackets(obj, t, Math.PI / 4, iter).next().value, tol, iter).slice(-1);
                const [pE, pF, pG] = fold(t).slice(0, -1);

                // function obj(t){
                //     pK = roro(pA, np.array([0, 0, 1]), t) + np.array([0, 0, pG[2] + pE[2]])
                //     return np.linalg.norm(pK - pF) - b
                // }
                obj = (t) =>
                    pA
                        .roro([0, 0, 1], t)
                        .add([0, 0, pG[2] + pE[2]])
                        .sub(pF)
                        .norm() - b;
                // t = next(bisection(obj, a, b, tol=tol, iter=iter)[2] for a, b in brackets(obj, 0, 2 * np.pi, iter))
                t = bisection(obj, ...brackets(obj, 0, 2 * Math.PI, iter).next().value, tol, iter).slice(-1);
                const pK = pA.roro([0, 0, 1], t).add([0, 0, pG[2] + pE[2]]);
                const pI = pK
                    .sub([0, 0, pK[2]])
                    .uvec()
                    .roro([0, 0, 1], Math.PI / 2)
                    .mul(pD[1])
                    .add([0, 0, pG[2] + pE[2] - pD[2]]);

                coor = [pA, pB, pC, pD, pE, pF, pG, pG.roro([0, 0, 1], Math.PI), pI, pI.roro([0, 0, 1], Math.PI), pK, pK.roro([0, 0, 1], Math.PI)];

                return coor.map((e) => e.add([0, 0, (coor[0][2] - coor.slice(-1)[0][2]) / 2]));
            }

            function params() {
                return Object.fromEntries(Object.keys(DEFAULTS).map((k) => [k, DEFAULTS[k](document.getElementById(k))]));
            }

            function calc_tile(t, R) {
                const r = R * (SQRT3 / 2);
                let tile;
                if (t === "hex") {
                    tile = {
                        basis: [
                            [2 * r, 0],
                            [r, SQRT3 * r],
                        ],
                        tile: (e) => [
                            new Path.RegularPolygon({
                                center: e.coor,
                                sides: 6,
                                radius: R,
                                data: { mer: 1 },
                            }),
                        ],
                        radius: R,
                    };
                } else if (t === "trihex") {
                    tile = {
                        basis: [
                            [2 * R, 0],
                            [R, R * SQRT3],
                        ],
                        tile: (e) => [
                            new Path.RegularPolygon({
                                center: e.coor,
                                sides: 6,
                                radius: R,
                                data: { mer: 1 },
                            }).rotate(30),
                            ...Array.from({ length: 2 }, (_, i) =>
                                new Path.RegularPolygon({
                                    center: e.coor.add([R, -(1 / 3) * r]),
                                    sides: 3,
                                    radius: (2 / 3) * r,
                                    data: { mer: 2 },
                                })
                                    .rotate(180)
                                    .rotate(i * 60, e.coor)
                            ),
                        ],
                        radius: 2 * r,
                    };
                } else if (t === "snubhex") {
                    tile = {
                        basis: [
                            [2.5 * R, r],
                            [0.5 * R, 3 * r],
                        ],
                        tile: (e) => [
                            new Path.RegularPolygon({
                                center: e.coor,
                                sides: 6,
                                radius: R,
                                data: { mer: 1 },
                            }).rotate(30),
                            ...Array.from({ length: 6 }, (_, i) =>
                                new Path.RegularPolygon({
                                    center: e.coor.add([0, -r - (1 / 3) * r]),
                                    sides: 3,
                                    radius: (2 / 3) * r,
                                    data: { mer: 2 },
                                }).rotate(i * 60, e.coor)
                            ),
                            new Path.RegularPolygon({
                                center: e.coor.add([1.5 * R, -(1 / 3) * r]),
                                sides: 3,
                                radius: (2 / 3) * r,
                                data: { mer: 2 },
                            }),
                            new Path.RegularPolygon({
                                center: e.coor.add([-1.5 * R, (2 / 3) * r]),
                                sides: 3,
                                radius: (2 / 3) * r,
                                data: { mer: 2 },
                            }).rotate(180),
                        ],
                        radius: 2 * r,
                    };
                } else if (t === "rhombitrihex") {
                    tile = {
                        basis: [
                            [R + r + 0.5 * R, 0.5 * R + r],
                            [0, 2 * r + R],
                        ],
                        tile: (e) => [
                            new Path.RegularPolygon({
                                center: e.coor,
                                sides: 6,
                                radius: R,
                                data: { mer: 1 },
                            }).rotate(30),
                            ...Array.from({ length: 3 }, (_, i) =>
                                new Path.RegularPolygon({
                                    center: e.coor.add([0, R + R * (SQRT3 / 3)]),
                                    sides: 3,
                                    radius: R / SQRT3,
                                    data: { mer: 2 },
                                }).rotate(-30 + i * -60, e.coor)
                            ),
                            ...Array.from({ length: 3 }, (_, i) =>
                                new Path.RegularPolygon({
                                    center: e.coor.add([0, -r - 0.5 * R]),
                                    sides: 4,
                                    radius: Math.sqrt(2 * R * R) / 2,
                                    data: { mer: 3 },
                                }).rotate(i * 60, e.coor)
                            ),
                        ],
                        radius: Math.sqrt(Math.pow(r + R, 2) + Math.pow(R / 2, 2)),
                    };
                } else if (t === "dualhex") {
                    tile = {
                        basis: [
                            [(3 / 2) * R, r],
                            [0, 2 * r],
                        ],
                        tile: (e) =>
                            Array.from({ length: 6 }, (_, i) =>
                                new Path.RegularPolygon({
                                    center: e.coor.add([0, r - (R * SQRT3) / 6]),
                                    sides: 3,
                                    radius: R / SQRT3,
                                    data: { mer: 1 },
                                }).rotate(i * 60, e.coor)
                            ),
                        radius: R,
                    };
                } else if (t === "dualtrihex") {
                    tile = {
                        basis: [
                            [2 * r, 0],
                            [r, SQRT3 * r],
                        ],
                        tile: (e) => [
                            ...Array.from({ length: 6 }, (_, i) =>
                                new Path({
                                    segments: [
                                        [0, 0],
                                        [0.5 * r, -(0.25 * R * Math.sin(Math.PI / 6)) / Math.cos(Math.PI / 3)],
                                        [r, 0],
                                        [0.5 * r, (0.25 * R * Math.sin(Math.PI / 6)) / Math.cos(Math.PI / 3)],
                                    ].map((f) => e.coor.add(f)),
                                    closed: true,
                                    data: { mer: 1 },
                                }).rotate(i * 60, e.coor)
                            ),
                            ...Array.from({ length: 6 }, (_, i) =>
                                new Path({
                                    segments: [
                                        [-0.5 * r, 0.5 * R + (0.25 * R * Math.sin(Math.PI / 6)) / Math.cos(Math.PI / 3)],
                                        [0, 0.5 * R],
                                        [r - 0.5 * r, 0.5 * R + (0.25 * R * Math.sin(Math.PI / 6)) / Math.cos(Math.PI / 3)],
                                        [0, 0.5 * R + (2 * (0.25 * R * Math.sin(Math.PI / 6))) / Math.cos(Math.PI / 3)],
                                    ].map((f) => e.coor.add(f)),
                                    closed: true,
                                    data: { mer: 2 },
                                }).rotate(i * 60, e.coor)
                            ),
                        ],
                        radius: R,
                    };
                } else if (t === "dualsnubhex") {
                    tile = {
                        basis: [
                            [2.5 * R, r],
                            [0.5 * R, 2 * r + 2 * ((R * SQRT3) / 3) - (R * SQRT3) / 6],
                        ],
                        tile: (e) =>
                            Array.from({ length: 6 }, (_, i) =>
                                new Path({
                                    segments: [
                                        [0, 0],
                                        [0, r + (R * SQRT3) / 6],
                                        [0.5 * R, r + (R * SQRT3) / 3],
                                        [R, r + (R * SQRT3) / 6],
                                        [R, (R * SQRT3) / 3],
                                    ].map((f) => e.coor.add(f)),
                                    closed: true,
                                    data: { mer: 1 },
                                }).rotate(i * 60, e.coor)
                            ),
                        radius: r + (R * SQRT3) / 3,
                    };
                } else if (t === "dualrhombitrihex") {
                    tile = {
                        basis: [
                            [(3 / 2) * R, r],
                            [0, 2 * r],
                        ],
                        tile: (e) =>
                            Array.from({ length: 6 }, (_, i) =>
                                new Path({
                                    segments: [
                                        [0, 0],
                                        [0, r],
                                        [0.5 * R, r],
                                        [(SQRT3 / 2) * r, 0.5 * r],
                                    ].map((f) => e.coor.add(f)),
                                    closed: true,
                                    data: { mer: 1 },
                                }).rotate(i * 60, e.coor)
                            ),
                        radius: R,
                    };
                } else {
                    throw new Error("incorrect tile mode");
                }
                return tile;
            }

            function draw1() {
                const PARAMS = params();
                const tile = calc_tile(PARAMS.t, PARAMS.R);
                const ck = ck_vectors(tile.basis, PARAMS.h, PARAMS.k, PARAMS.H, PARAMS.K);
                const bounds = [[0, 0]].concat(ck.map((e) => mmul(T(inv2(tile.basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round)));

                const g = Array.from(grid(ck, tile.basis));
                let lattice = g.map(tile.tile);
                let points = g
                    .filter((e) => e.is_vertex)
                    .map((e) => e.coor)
                    .concat([[0, 0]]);

                lattice.flat().forEach((e) => {
                    const offset = e.data.mer + (points.some((v) => [e.position.x, e.position.y].sub(v).norm() <= tile.radius) ? 0 : 3);
                    e.style.fillColor = PARAMS["mer_color_" + offset] + PARAMS["mer_alpha_" + offset];
                });

                let triangles = [
                    [ck[3], ck[0]],
                    [ck[0], ck[1]],
                    [ck[1], ck[2]],
                ].map((e) => new Path({ segments: [[0, 0], ...e], strokeWidth: 4, closed: true, data: { vectors: [[0, 0], ...e] } }));

                new Group({
                    children: lattice.flat().concat(triangles),
                    position: view.center,
                    strokeColor: PARAMS.line_color + PARAMS.line_alpha,
                    strokeWidth: PARAMS.line_width,
                    strokeCap: "round",
                    strokeJoin: "round",
                }).scale(-1, 1);
            }

            function draw2() {
                const PARAMS = params();
                const tile = calc_tile(PARAMS.t, PARAMS.R);
                const ck = ck_vectors(tile.basis, PARAMS.h, PARAMS.k, PARAMS.H, PARAMS.K);
                const bounds = [[0, 0]].concat(ck.map((e) => mmul(T(inv2(tile.basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round)));

                const g = Array.from(grid(ck, tile.basis));
                let lattice = g.map(tile.tile);
                let points = g
                    .filter((e) => e.is_vertex)
                    .map((e) => e.coor)
                    .concat([[0, 0]]);

                lattice.flat().forEach((e) => {
                    const offset = e.data.mer + (points.some((v) => [e.position.x, e.position.y].sub(v).norm() <= tile.radius) ? 0 : 3);
                    e.data.offset = offset;
                    e.data.centroid = e.segments
                        .map((e) => e.point)
                        .reduce((a, b) => a.add(b), new Point([0, 0]))
                        .divide(e.segments.length);
                    e.style.fillColor = PARAMS["mer_color_" + offset] + PARAMS["mer_alpha_" + offset];
                });

                let triangles = [
                    [ck[3], ck[0]],
                    [ck[0], ck[1]],
                    [ck[1], ck[2]],
                ].map((e) => new Path({ segments: [[0, 0], ...e], closed: true, data: { vectors: [[0, 0], ...e] } }));
                let faces = triangles.map(
                    (e) =>
                        new Group({
                            children: lattice
                                .flatMap((f) =>
                                    f.map((g) => {
                                        let x = g.intersect(e);
                                        x.data.has_centroid = e.contains(x.data.centroid);
                                        x.data.centroid_on_vertex = e.segments.map((h) => h.point.getDistance(x.data.centroid)).some((e) => e < 1e-5);
                                        return x;
                                    })
                                )
                                .filter((e) => e.segments.length > 0),
                            data: e.data,
                        })
                );

                const CAMERA = camera(...[PARAMS.θ, PARAMS.ψ, PARAMS.φ].map(radians));
                const AXIS = mmul(CAMERA, [0, 0, 1, 1].T());
                let ico_axis = ["", ico_axis_2, ico_axis_3, "", ico_axis_5][PARAMS.s - 1];
                let coors = ico_axis(ck).map((e) => mmul(CAMERA, e.concat(1).T()).flat());

                let [t_idx, t_id, v_idx, t_rep, v_con] = ico_config(PARAMS.s);
                const th = (2 * Math.PI) / PARAMS.s;

                let results = [];
                for (let idx = 0; idx < t_idx.length; idx++) {
                    let face = faces[t_idx[idx] - 1];
                    let A = T(face.data.vectors.map((e) => e.concat(1)));
                    let V = [0, 1, 2].map((e) => coors[v_idx[idx][e]]);
                    for (let i = 0; i < t_rep[idx]; i++) {
                        let X = V.map((e) => e.roro(AXIS, i * th));
                        let centroid = X.reduce((a, b) => a.add(b)).div(X.length);
                        let M = mmul([...T(X).slice(0, 2), [1, 1, 1]], inv3(A));
                        let result = face.clone().transform(new paper.Matrix(M[0][0], M[1][0], M[0][1], M[1][1], M[0][2], M[1][2]));
                        result.data.M = mmul(T(X), inv3(A));
                        result.data.centroid = centroid;
                        result.data.normal = X[1].sub(X[0]).cross(X[2].sub(X[0])).uvec();
                        results.push(result);
                    }
                }

                let fibers = results.flatMap((e, i) =>
                    e.children
                        .filter((f) => PARAMS["mer_toggle_" + f.data.offset] && f.data.has_centroid)
                        .map((f, j) => {
                            const from = mmul(e.data.M, [f.data.centroid.x, f.data.centroid.y, 1].T()).flat();
                            const sign = from.uvec().dot(e.data.normal) < 1e-15 ? -1 : 1;
                            const to = from.add(e.data.normal.mul(sign));
                            return [from, to];
                        })
                );
                let groups = [];
                fibers.forEach((e) => {
                    let i = 0;
                    for (let g of groups) if (e[0].sub(g[0][0]).norm() < 1e-5) i = g.push(e);
                    if (i === 0) groups.push([e]);
                });
                fibers = groups
                    .map((e) => [
                        e[0][0],
                        e
                            .map((f) => f[1])
                            .reduce((a, b) => a.add(b), [0, 0, 0])
                            .div(e.length),
                    ])
                    .map((e) => {
                        const [from, to] = [e[1], e[0].add(e[1].sub(e[0]).mul(PARAMS.fiber_length))];
                        return new Path.Line({
                            from: from,
                            to: to,
                            data: { centroid: to.mul(1000) },
                        });
                    });
                if (PARAMS["penton_fiber_toggle"]) {
                    fibers = fibers.concat(
                        v_con
                            .map((e) =>
                                e
                                    .map((f) => coors[f])
                                    .reduce((a, b) => a.add(b), [0, 0, 0])
                                    .uvec()
                            )
                            .map((e, i) => {
                                const [from, to] = [coors[i], coors[i].add(e.mul(PARAMS.fiber_length))];
                                return new Path.Line({
                                    from: from,
                                    to: to,
                                    data: { centroid: to.mul(1000) },
                                });
                            })
                    );
                }
                results = results.concat(fibers);
                results.sort((a, b) => a.data.centroid[2] < b.data.centroid[2]);
                new Group({
                    children: results,
                    position: view.center,
                    style: { strokeColor: PARAMS.line_color + PARAMS.line_alpha, strokeWidth: PARAMS.line_width, strokeCap: "round", strokeJoin: "round" },
                });

                fibers.forEach((e) => {
                    e.style.strokeColor = PARAMS.fiber_color + PARAMS.fiber_alpha;
                    e.style.strokeWidth = PARAMS.fiber_width;
                });

                faces.forEach((e) => e.remove());
                triangles.forEach((e) => e.remove());
                lattice.forEach((e) => e.forEach((f) => f.remove()));
            }

            function update(e) {
                paper.clear();
                paper.setup("canvas1");
                draw1();
                paper.setup("canvas2");
                draw2();
            }

            paper.install(window);

            window.onload = function (opt) {
                Object.keys(DEFAULTS).forEach((e) => document.getElementById(e).addEventListener("change", update));
                update();
            };
        </script>
    </head>
    <body>
        <div>
            <canvas id="canvas1" resize> Your browser does not support the HTML canvas tag. </canvas>
            <canvas id="canvas2" resize> Your browser does not support the HTML canvas tag. </canvas>
        </div>
        <br />
        <fieldset>
            <legend>model</legend>
            <div>
                <label for="h">h&nbsp;=&nbsp;</label>
                <input type="number" id="h" step="1" value="1" min="0" />
                <label for="k">k&nbsp;=&nbsp;</label>
                <input type="number" id="k" step="1" value="1" min="0" />
                <label for="H">H&nbsp;=&nbsp;</label>
                <input type="number" id="H" step="1" value="1" min="0" />
                <label for="K">K&nbsp;=&nbsp;</label>
                <input type="number" id="K" step="1" value="2" min="0" />
            </div>
            <div>
                <label for="s">S&nbsp;=&nbsp;</label>
                <select id="s">
                    <option value="5">5</option>
                    <option value="3">3</option>
                    <option value="2">2</option>
                </select>
                <label for="R">R&nbsp;=&nbsp;</label>
                <input type="number" id="R" step="1" value="10" min="1" />
                <label for="t">t&nbsp;=&nbsp;</label>
                <select id="t">
                    <option value="hex">hex</option>
                    <option value="trihex">trihex</option>
                    <option value="snubhex">snubhex</option>
                    <option value="rhombitrihex">rhombitrihex</option>
                    <option value="dualhex">dualhex</option>
                    <option value="dualtrihex">dualtrihex</option>
                    <option value="dualsnubhex">dualsnubhex</option>
                    <option value="dualrhombitrihex">dualrhombitrihex</option>
                </select>
            </div>
        </fieldset>
        <fieldset>
            <legend>rotation</legend>
            <label for="θ">θ&nbsp;=&nbsp;</label>
            <input type="number" id="θ" step="10" value="0" min="0" />
            <label for="ψ">ψ&nbsp;=&nbsp;</label>
            <input type="number" id="ψ" step="10" value="0" min="0" />
            <label for="φ">φ&nbsp;=&nbsp;</label>
            <input type="number" id="φ" step="10" value="0" min="0" />
        </fieldset>
        <fieldset>
            <legend>perspective</legend>
        </fieldset>
        <fieldset>
            <legend>fiber</legend>
            <label for="pen_fiber">penton</label>
            <input type="checkbox" id="penton_fiber_toggle" checked />
            <label for="hex_fiber">hexon</label>
            <input type="checkbox" id="hexon_fiber_toggle" />
        </fieldset>
        <fieldset>
            <legend>aesthetics</legend>
            <table>
                <tbody>
                    <tr>
                        <th></th>
                        <th>line</th>
                        <th>fiber</th>
                        <th>knob</th>
                    </tr>
                    <tr>
                        <td>color</td>
                        <td><input type="color" id="line_color" , value="#000000" /></td>
                        <td><input type="color" id="fiber_color" value="#eded61" /></td>
                        <td><input type="color" id="knob_color" value="#ffa500" /></td>
                    </tr>
                    <tr>
                        <td>alpha</td>
                        <td><input type="number" id="line_alpha" step="1" value="255" min="0" max="255" /></td>
                        <td><input type="number" id="fiber_alpha" step="1" value="255" min="0" max="255" /></td>
                        <td><input type="number" id="knob_alpha" step="1" value="255" min="0" max="255" /></td>
                    </tr>
                    <tr>
                        <td>width</td>
                        <td><input type="number" id="line_width" step="0.5" value="2" min="0" /></td>
                        <td><input type="number" id="fiber_width" step="0.5" value="4" min="0" /></td>
                        <td><input type="number" id="knob_width" step="0.5" value="2" min="0" /></td>
                    </tr>
                    <tr>
                        <td>length</td>
                        <td>n/a</td>
                        <td><input type="number" id="fiber_length" step="1" value="20" min="0" /></td>
                        <td>n/a</td>
                    </tr>
                </tbody>
            </table>
            <br />
            <table>
                <tbody>
                    <tr>
                        <th></th>
                        <th>pentamer-1</th>
                        <th>pentamer-2</th>
                        <th>pentamer-3</th>
                        <th>hexamer-1</th>
                        <th>hexamer-2</th>
                        <th>hexamer-3</th>
                    </tr>
                    <tr>
                        <td>color</td>
                        <td><input type="color" id="mer_color_1" value="#6da59b" /></td>
                        <td><input type="color" id="mer_color_2" value="#aed6d4" /></td>
                        <td><input type="color" id="mer_color_3" value="#8291c2" /></td>
                        <td><input type="color" id="mer_color_4" value="#92be5f" /></td>
                        <td><input type="color" id="mer_color_5" value="#44782c" /></td>
                        <td><input type="color" id="mer_color_6" value="#3278ad" /></td>
                    </tr>
                    <tr>
                        <td>alpha</td>
                        <td><input type="number" id="mer_alpha_1" step="1" value="255" min="0" max="255" /></td>
                        <td><input type="number" id="mer_alpha_2" step="1" value="255" min="0" max="255" /></td>
                        <td><input type="number" id="mer_alpha_3" step="1" value="255" min="0" max="255" /></td>
                        <td><input type="number" id="mer_alpha_4" step="1" value="255" min="0" max="255" /></td>
                        <td><input type="number" id="mer_alpha_5" step="1" value="255" min="0" max="255" /></td>
                        <td><input type="number" id="mer_alpha_6" step="1" value="255" min="0" max="255" /></td>
                    </tr>
                    <tr>
                        <td>fiber</td>
                        <td><input type="checkbox" id="mer_toggle_1" /></td>
                        <td><input type="checkbox" id="mer_toggle_2" /></td>
                        <td><input type="checkbox" id="mer_toggle_3" /></td>
                        <td><input type="checkbox" id="mer_toggle_4" /></td>
                        <td><input type="checkbox" id="mer_toggle_5" /></td>
                        <td><input type="checkbox" id="mer_toggle_6" /></td>
                    </tr>
                </tbody>
            </table>
        </fieldset>
    </body>
</html>
