<!DOCTYPE html>
<meta charset="UTF-8" />
<html lang="en">
    <head>
        <title>capsid</title>
        <style>
            html {
                background-color: #fdfdfd;
            }
            body {
                font-family: "Lucida Console", "Courier New", monospace;
            }
            canvas {
                height: 250px;
                width: 575px;
                border: 1px solid blue;
            }
        </style>
        <script type="text/javascript" src="js/lib/paper-js/paper-core.min.js"></script>
        <script type="text/javascript" src="js/linalg.js"></script>
        <script type="text/javascript">
            const SQRT3 = Math.sqrt(3);
            const SQRT5 = Math.sqrt(5);

            function hex_basis(R = 1) {
                // ⬡
                const r = R * (SQRT3 / 2); // hexagon inradius
                return [
                    [1, 0].mul(2 * r), // →
                    [0.5, SQRT3 / 2].mul(2 * r), // ↗
                ];
            }

            function ck_vectors(h, k, H, K, R = 1) {
                const [v1, v2, v3] = hex_basis(R).concat([[-0.5, SQRT3 / 2].mul(2 * (R * (SQRT3 / 2)))]);
                return [
                    //
                    v1.mul(h).add(v2.mul(k)),
                    v2.mul(H).add(v3.mul(K)),
                    v1.mul(-h - k).add(v2.mul(h)),
                    v1.mul(k).add(v3.mul(-h)),
                ];
            }

            function ico_axis_5(ck) {
                const a = ck[0].norm();
                const b = ck[1].norm();

                // regular pentagon circumradius
                const R5 = a * Math.sqrt((5 + SQRT5) / 10);
                // regular pentagonal pyramid height
                const h5 = ((1 + SQRT5) * a) / (2 * Math.sqrt(5 + 2 * SQRT5));

                const pA = [0, 0, h5];
                const pB = [-R5, 0, 0].roro([0, 0, 1], (3 / 10) * Math.PI); // 54°
                const pC = pB.add([a, 0, 0]);

                const t = ck[0].angle(ck[1]);
                const q = pC.add([b, 0, 0].roro([0, 1, 0], -Math.PI - t));
                const p = pB.add(q.sub(pB).proj(pC.sub(pB)));
                const d = [p[0], (-Math.abs(p[1]) * Math.sqrt(R5 * R5 * p[1] * p[1] - (p[0] * p[1]) ** 2)) / (p[1] * p[1]), 0];

                const pG = d.add([0, 0, -Math.sqrt(q[2] * q[2] - (p[1] - d[1]) ** 2)]);
                const coor = [pA, pB, pC]
                    .concat([1, 2, 3].map((e) => pC.roro([0, 0, 1], ((e * 2) / 5) * Math.PI)))
                    .concat([pG])
                    .concat([1, 2, 3, 4].map((e) => pG.roro([0, 0, 1], ((e * 2) / 5) * Math.PI)))
                    .concat([[0, 0, pG[2] - pA[2]]]);

                return coor.map((e) => e.add([0, 0, -pG[2] / 2]));
            }

            function ico_axis_3(ck, iter = 100, tol = 1e-15) {
                const a = ck[0].norm();
                const b = ck[1].norm();
                const c = ck[2].sub(ck[1]).norm();

                const pA = [0, a * (1 / SQRT3), 0];
                const pB = [a / 2, -(a * (SQRT3 / 6)), 0];
                const pC = [-(a / 2), -(a * (SQRT3 / 6)), 0];
                const qD = [0, -(a * ((2 * SQRT3) / 3)), 0];
                const qF = [a, a / SQRT3, 0];

                function fold(t) {
                    let [v, k] = [qD.uvec().mul(a * (SQRT3 / 2)), pB.sub(pC).uvec()];
                    const pD = [0, -(a * (SQRT3 / 6)), 0].add(v.roro(k, t));
                    const pF = pD.roro([0, 0, 1], (2 / 3) * Math.PI);
                    t = ck[0].angle(ck[1]);
                    [v, k] = [pD.sub(pB).uvec().mul(b), pD.cross(pB).uvec()];
                    const o = v.roro(k, t);
                    const [p, q] = [pB.add(o.proj(v)), pB.add(o)];
                    [v, k] = [q.sub(p), pB.sub(pD).uvec()];
                    // f = lambda t: c - np.linalg.norm((p + roro(v, k, t)) - pF)
                    let f = (t) => c - p.add(v.roro(k, t)).sub(pF).norm();
                    let br = brackets(f, 0, 2 * Math.PI, iter).next().value;
                    // t = bisect_brackets(f, 0, 2 * Math.PI, tol, iter).next().value[2];
                    t = bisection(f, ...brackets(f, 0, 2 * Math.PI, iter).next().value, tol, iter).slice(-1);
                    // for (let [a, b] of brackets(f, 0, 2 * Math.PI, iter)) {
                    //     t = bisection(f, a, b, tol, iter);
                    //     break;
                    // }
                    const pG = p.add(v.roro(k, t));
                    return [pD, pF, pG, Math.abs(pD[1]) - pG.sub([0, 0, pG[2]]).norm()];
                }

                const delta = Math.PI / 180 / 10;
                t = 0;
                for (let i = 0; i * delta < Math.PI / 2; i++) {
                    t = i * delta;
                    try {
                        fold(t);
                        break;
                    } catch (e) {}
                }
                // bisection(f, ...brackets(f, 0, 2 * Math.PI, iter).next().value, tol, iter).slice(-1)
                // obj = lambda t: fold(t)[-1]
                // t = next(bisection(obj, a, b, tol=tol, iter=iter)[2] for a, b in brackets(obj, t, np.pi / 4, iter))
                let obj = (t) => fold(t).slice(-1)[0];
                t = bisection(obj, ...brackets(obj, t, Math.PI / 4, iter).next().value, tol, iter).slice(-1);

                const [pD, pF, pG] = fold(t).slice(0, -1);
                const k = [0, 0, 1];
                t = (2 * Math.PI) / 3;
                const pH = pG.roro(k, -t);
                const pJ = pH
                    .sub([0, 0, pH[2]])
                    .roro(k, Math.PI / 3)
                    .uvec()
                    .mul(pA[1])
                    .add([0, 0, pH[2] + pD[2] - pA[2]]);

                let coor = [pA, pB, pC, pD, pF.roro(k, t), pF, pG, pH, pH.roro(k, -t), pJ, pJ.roro(k, -t), pJ.roro(k, -2 * t)];
                return coor.map((e) => e.add([0, 0, (coor[0][2] - coor.slice(-1)[0][2]) / 2]));
            }

            function params() {
                return Object.fromEntries(["h", "k", "H", "K", "R", "θ", "ψ", "φ"].map((e) => [e, parseFloat(document.getElementById(e).value)]));
            }

            function intersect(p, q) {
                let x = p.intersect(q);
                p.remove();
                return x;
            }

            function* grid(ck, basis) {
                const bounds = ck.map((e) => mmul(T(inv2(basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round));
                const [min_i, min_j, max_i, max_j] = [
                    //
                    ...[0, 1].map((_, i) => Math.min(...bounds.map((e) => e[i]))),
                    ...[0, 1].map((_, i) => Math.max(...bounds.map((e) => e[i]))),
                ];
                for (let i = min_i; i < max_i + 1; i++) {
                    for (let j = min_j; j < max_j + 1; j++) {
                        yield { index: [i, j], coor: basis[0].mul(i).add(basis[1].mul(j)) };
                    }
                }
            }

            function radians(x) {
                return (x * Math.PI) / 180;
            }

            function draw1() {
                const PARAMS = params();
                const ck = ck_vectors(PARAMS.h, PARAMS.k, PARAMS.H, PARAMS.K, PARAMS.R);
                const basis = hex_basis(PARAMS.R);

                const bounds = [[0, 0]].concat(ck.map((e) => mmul(T(inv2(basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round)));

                let lattice = Array.from(grid(ck, basis)).map((e) => {
                    return new Path.RegularPolygon({
                        center: e.coor,
                        fillColor: bounds.some((v) => v.every((u, i) => u == e.index[i])) ? "black" : "white",
                        sides: 6,
                        radius: PARAMS.R,
                        strokeColor: "black",
                        strokeWidth: 2,
                        strokeCap: "round",
                        strokeJoin: "round",
                    });
                });

                let triangles = [
                    [ck[3], ck[0]],
                    [ck[0], ck[1]],
                    [ck[1], ck[2]],
                ]
                    .map((e) => new Path({ segments: [[0, 0], ...e, [0, 0]], data: { vectors: [[0, 0], ...e] } }))
                    .map(
                        (e) =>
                            new Group({
                                children: lattice.map((f) => intersect(f, e)),
                                data: e.data,
                            })
                    );

                new Group({ children: triangles, position: view.center });

                lattice.forEach((e) => e.remove());
            }

            function draw2() {
                const PARAMS = params();
                const ck = ck_vectors(PARAMS.h, PARAMS.k, PARAMS.H, PARAMS.K, PARAMS.R);
                const basis = hex_basis(PARAMS.R);
                const bounds = [[0, 0]].concat(ck.map((e) => mmul(T(inv2(basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round)));

                let lattice = Array.from(grid(ck, basis)).map((e) => {
                    return new Path.RegularPolygon({
                        center: e.coor,
                        fillColor: bounds.some((v) => v.every((u, i) => u == e.index[i])) ? "black" : "white",
                        sides: 6,
                        radius: PARAMS.R,
                        strokeColor: "black",
                        strokeWidth: 2,
                        strokeCap: "round",
                        strokeJoin: "round",
                    });
                });

                let triangles = [
                    [ck[3], ck[0]],
                    [ck[0], ck[1]],
                    [ck[1], ck[2]],
                ]
                    .map((e) => new Path({ segments: [[0, 0], ...e, [0, 0]], data: { vectors: [[0, 0], ...e] } }))
                    .map(
                        (e) =>
                            new Group({
                                children: lattice.map((f) => intersect(f, e)),
                                data: e.data,
                            })
                    );

                const CAMERA = camera(...[PARAMS.θ, PARAMS.ψ, PARAMS.φ].map(radians));
                const AXIS = mmul(CAMERA, [0, 0, 1, 1].T());
                let coors = ico_axis_3(ck).map((e) => mmul(CAMERA, e.concat(1).T()).flat());
                console.log(coors);
                const th = (2 * Math.PI) / 3;
                // let [t_idx, t_id, v_idx] = [
                //     [1, 1, 2, 2],
                //     ["T1-▲", "T1-▼", "T2-▲", "T2-▼"],
                //     [
                //         [0, 1, 2],
                //         [6, 11, 7],
                //         [2, 1, 6],
                //         [6, 7, 2],
                //     ],
                // ];
                let [t_idx, t_id, v_idx] = [
                    [1, 1, 1, 1, 2, 2, 3, 3],
                    ["T1-▔", "T1-▲", "T1-▼", "T1-▁", "T2-▼", "T2-▲", "T3-▼", "T3-▲"],
                    [
                        [0, 2, 1],
                        [1, 2, 3],
                        [6, 11, 9],
                        [9, 11, 10],
                        [1, 3, 6],
                        [9, 6, 3],
                        [1, 6, 5],
                        [11, 5, 6],
                    ],
                ];

                let results = [];
                for (let idx = 0; idx < t_idx.length; idx++) {
                    let triangle = triangles[t_idx[idx] - 1];
                    let A = T(triangle.data.vectors.map((e) => e.concat(1)));
                    let V = [0, 1, 2].map((e) => coors[v_idx[idx][e]]);
                    for (let i = 0; i < 5; i++) {
                        let X = V.map((e) => e.roro(AXIS, i * th));
                        let centroid = X.reduce((a, b) => a.add(b)).div(X.length);
                        let M = mmul([...T(X).slice(0, 2), [1, 1, 1]], inv3(A));
                        let face = triangle.clone().transform(new paper.Matrix(M[0][0], M[1][0], M[0][1], M[1][1], M[0][2], M[1][2]));
                        face.data.centroid = centroid;
                        results.push(face);
                    }
                }
                results.sort((a, b) => a.data.centroid[2] < b.data.centroid[2]);
                new Group({
                    children: results,
                    position: view.center,
                    style: { strokeCap: "round", strokeJoin: "round" },
                });

                triangles.forEach((e) => e.remove());
                lattice.forEach((e) => e.remove());
            }

            function update(e) {
                paper.clear();
                paper.setup("canvas1");
                draw1();
                paper.setup("canvas2");
                draw2();
            }

            paper.install(window);

            window.onload = function (opt) {
                ["h", "k", "H", "K", "R", "θ", "ψ", "φ"].forEach((e) => document.getElementById(e).addEventListener("change", update));
                update();
            };
        </script>
    </head>
    <body>
        <div>
            <label for="h">h&nbsp;=&nbsp;</label>
            <input type="number" id="h" step="1" value="1" min="0" />
            <label for="k">k&nbsp;=&nbsp;</label>
            <input type="number" id="k" step="1" value="1" min="0" />
            <label for="H">H&nbsp;=&nbsp;</label>
            <input type="number" id="H" step="1" value="1" min="0" />
            <label for="K">K&nbsp;=&nbsp;</label>
            <input type="number" id="K" step="1" value="2" min="0" />
            <label for="s">S&nbsp;=&nbsp;</label>
            <select id="s">
                <option value="5">5</option>
                <option value="3">3</option>
                <option value="2">2</option>
            </select>
            <div>
                <label for="R">R&nbsp;=&nbsp;</label>
                <input type="number" id="R" step="1" value="10" min="1" />
            </div>
        </div>
        <div>
            <label for="θ">θ&nbsp;=&nbsp;</label>
            <input type="number" id="θ" step="10" value="0" min="0" />
            <label for="ψ">ψ&nbsp;=&nbsp;</label>
            <input type="number" id="ψ" step="10" value="0" min="0" />
            <label for="φ">φ&nbsp;=&nbsp;</label>
            <input type="number" id="φ" step="10" value="0" min="0" />
        </div>
        <br />
        <div>
            <canvas id="canvas1" resize> Your browser does not support the HTML canvas tag. </canvas>
            <canvas id="canvas2" resize> Your browser does not support the HTML canvas tag. </canvas>
        </div>
    </body>
</html>
