<!DOCTYPE html>
<meta charset="UTF-8" />
<html lang="en">
    <head>
        <title>capsid</title>
        <style>
            html {
                background-color: #fdfdfd;
            }
            body {
                font-family: "Lucida Console", "Courier New", monospace;
            }
            canvas {
                height: 250px;
                width: 575px;
                border: 1px solid blue;
            }
        </style>
        <script type="text/javascript" src="js/lib/paper-js/paper-core.min.js"></script>
        <script type="text/javascript" src="js/linalg.js"></script>
        <script type="text/javascript">
            const SQRT3 = Math.sqrt(3);
            const SQRT5 = Math.sqrt(5);

            function hex_basis(R = 1) {
                // ⬡
                const r = R * (SQRT3 / 2); // hexagon inradius
                return [
                    [1, 0].mul(2 * r), // →
                    [0.5, SQRT3 / 2].mul(2 * r), // ↗
                ];
            }

            function ck_vectors(h, k, H, K, R = 1) {
                const [v1, v2, v3] = hex_basis(R).concat([[-0.5, SQRT3 / 2].mul(2 * (R * (SQRT3 / 2)))]);
                return [
                    //
                    v1.mul(h).add(v2.mul(k)),
                    v2.mul(H).add(v3.mul(K)),
                    v1.mul(-h - k).add(v2.mul(h)),
                    v1.mul(k).add(v3.mul(-h)),
                ];
            }

            function ico_axis_5(C1, C2) {
                let a = C1.norm();
                let b = C2.norm();

                // regular pentagon circumradius
                let R5 = a * Math.sqrt((5 + SQRT5) / 10);
                // regular pentagonal pyramid height
                let h5 = ((1 + SQRT5) * a) / (2 * Math.sqrt(5 + 2 * SQRT5));

                let pA = [0, 0, h5];
                let pB = [-R5, 0, 0].roro([0, 0, 1], (3 / 10) * Math.PI); // 54°
                let pC = pB.add([a, 0, 0]);

                let t = C1.angle(C2);
                let q = pC.add([b, 0, 0].roro([0, 1, 0], -Math.PI - t));
                let p = pB.add(q.sub(pB).proj(pC.sub(pB)));
                let d = [p[0], (-Math.abs(p[1]) * Math.sqrt(R5 * R5 * p[1] * p[1] - (p[0] * p[1]) ** 2)) / (p[1] * p[1]), 0];

                let pG = d.add([0, 0, -Math.sqrt(q[2] * q[2] - (p[1] - d[1]) ** 2)]);
                let coor = [pA, pB, pC]
                    .concat([1, 2, 3].map((e) => pC.roro([0, 0, 1], ((e * 2) / 5) * Math.PI)))
                    .concat([pG])
                    .concat([1, 2, 3, 4].map((e) => pG.roro([0, 0, 1], ((e * 2) / 5) * Math.PI)))
                    .concat([[0, 0, pG[2] - pA[2]]]);

                return coor.map((e) => e.add([0, 0, -pG[2] / 2]));
            }

            function params() {
                return Object.fromEntries(["h", "k", "H", "K", "R", "θ", "ψ", "φ"].map((e) => [e, parseFloat(document.getElementById(e).value)]));
            }

            function intersect(p, q) {
                let x = p.intersect(q);
                p.remove();
                return x;
            }

            function* grid(ck, basis) {
                const bounds = ck.map((e) => mmul(T(inv2(basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round));
                const [min_i, min_j, max_i, max_j] = [
                    //
                    ...[0, 1].map((_, i) => Math.min(...bounds.map((e) => e[i]))),
                    ...[0, 1].map((_, i) => Math.max(...bounds.map((e) => e[i]))),
                ];
                for (let i = min_i; i < max_i + 1; i++) {
                    for (let j = min_j; j < max_j + 1; j++) {
                        yield { index: [i, j], coor: basis[0].mul(i).add(basis[1].mul(j)) };
                    }
                }
            }

            function radians(x) {
                return (x * Math.PI) / 180;
            }

            function draw1() {
                const PARAMS = params();
                const ck = ck_vectors(PARAMS.h, PARAMS.k, PARAMS.H, PARAMS.K, PARAMS.R);
                const basis = hex_basis(PARAMS.R);

                const bounds = [[0, 0]].concat(ck.map((e) => mmul(T(inv2(basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round)));

                let lattice = Array.from(grid(ck, basis)).map((e) => {
                    return new Path.RegularPolygon({
                        center: e.coor,
                        fillColor: bounds.some((v) => v.every((u, i) => u == e.index[i])) ? "black" : "white",
                        sides: 6,
                        radius: PARAMS.R,
                        strokeColor: "black",
                        strokeWidth: 2,
                        strokeCap: "round",
                        strokeJoin: "round",
                    });
                });

                let triangles = [
                    [ck[3], ck[0]],
                    [ck[0], ck[1]],
                    [ck[1], ck[2]],
                ]
                    .map((e) => new Path({ segments: [[0, 0], ...e, [0, 0]], data: { vectors: [[0, 0], ...e] } }))
                    .map(
                        (e) =>
                            new Group({
                                children: lattice.map((f) => intersect(f, e)),
                                data: e.data,
                            })
                    );

                new Group({ children: triangles, position: view.center });

                lattice.forEach((e) => e.remove());
            }

            function draw2() {
                const PARAMS = params();
                const ck = ck_vectors(PARAMS.h, PARAMS.k, PARAMS.H, PARAMS.K, PARAMS.R);
                const basis = hex_basis(PARAMS.R);
                const bounds = [[0, 0]].concat(ck.map((e) => mmul(T(inv2(basis)), [e, 1].flat().T()).flat()).map((e) => e.map(Math.round)));

                let lattice = Array.from(grid(ck, basis)).map((e) => {
                    return new Path.RegularPolygon({
                        center: e.coor,
                        fillColor: bounds.some((v) => v.every((u, i) => u == e.index[i])) ? "black" : "white",
                        sides: 6,
                        radius: PARAMS.R,
                        strokeColor: "black",
                        strokeWidth: 2,
                        strokeCap: "round",
                        strokeJoin: "round",
                    });
                });

                let triangles = [
                    [ck[3], ck[0]],
                    [ck[0], ck[1]],
                    [ck[1], ck[2]],
                ]
                    .map((e) => new Path({ segments: [[0, 0], ...e, [0, 0]], data: { vectors: [[0, 0], ...e] } }))
                    .map(
                        (e) =>
                            new Group({
                                children: lattice.map((f) => intersect(f, e)),
                                data: e.data,
                            })
                    );

                const CAMERA = camera(...[PARAMS.θ, PARAMS.ψ, PARAMS.φ].map(radians));
                const AXIS = mmul(CAMERA, [0, 0, 1, 1].T());
                let coors = ico_axis_5(ck[0], ck[1]).map((e) => mmul(CAMERA, e.concat(1).T()).flat());

                const th = (2 * Math.PI) / 5;
                let [t_idx, t_id, v_idx] = [
                    [1, 1, 2, 2],
                    ["T1-▲", "T1-▼", "T2-▲", "T2-▼"],
                    [
                        [0, 1, 2],
                        [6, 11, 7],
                        [2, 1, 6],
                        [6, 7, 2],
                    ],
                ];

                let results = [];
                for (let idx = 0; idx < t_idx.length; idx++) {
                    let triangle = triangles[t_idx[idx] - 1];
                    let A = T(triangle.data.vectors.map((e) => e.concat(1)));
                    let V = [0, 1, 2].map((e) => coors[v_idx[idx][e]]);
                    for (let i = 0; i < 5; i++) {
                        let X = V.map((e) => e.roro(AXIS, i * th));
                        let centroid = X.reduce((a, b) => a.add(b)).div(X.length);
                        let M = mmul([...T(X).slice(0, 2), [1, 1, 1]], inv3(A));
                        let face = triangle.clone().transform(new paper.Matrix(M[0][0], M[1][0], M[0][1], M[1][1], M[0][2], M[1][2]));
                        face.data.centroid = centroid;
                        results.push(face);
                    }
                }
                results.sort((a, b) => a.data.centroid[2] < b.data.centroid[2]);
                new Group({
                    children: results,
                    position: view.center,
                    style: { strokeCap: "round", strokeJoin: "round" },
                });

                triangles.forEach((e) => e.remove());
                lattice.forEach((e) => e.remove());
            }

            function update(e) {
                paper.clear();
                paper.setup("canvas1");
                draw1();
                paper.setup("canvas2");
                draw2();
            }

            paper.install(window);

            window.onload = function (opt) {
                ["h", "k", "H", "K", "R", "θ", "ψ", "φ"].forEach((e) => document.getElementById(e).addEventListener("change", update));
                update();
            };
        </script>
    </head>
    <body>
        <div>
            <label for="h">h&nbsp;=&nbsp;</label>
            <input type="number" id="h" step="1" value="1" min="0" />
            <label for="k">k&nbsp;=&nbsp;</label>
            <input type="number" id="k" step="1" value="1" min="0" />
            <label for="H">H&nbsp;=&nbsp;</label>
            <input type="number" id="H" step="1" value="1" min="0" />
            <label for="K">K&nbsp;=&nbsp;</label>
            <input type="number" id="K" step="1" value="2" min="0" />
            <label for="s">S&nbsp;=&nbsp;</label>
            <select id="s">
                <option value="5">5</option>
                <option value="3">3</option>
                <option value="2">2</option>
            </select>
            <div>
                <label for="R">R&nbsp;=&nbsp;</label>
                <input type="number" id="R" step="1" value="10" min="1" />
            </div>
        </div>
        <div>
            <label for="θ">θ&nbsp;=&nbsp;</label>
            <input type="number" id="θ" step="10" value="0" min="0" />
            <label for="ψ">ψ&nbsp;=&nbsp;</label>
            <input type="number" id="ψ" step="10" value="0" min="0" />
            <label for="φ">φ&nbsp;=&nbsp;</label>
            <input type="number" id="φ" step="10" value="0" min="0" />
        </div>
        <br />
        <div>
            <canvas id="canvas1" resize> Your browser does not support the HTML canvas tag. </canvas>
            <canvas id="canvas2" resize> Your browser does not support the HTML canvas tag. </canvas>
        </div>
    </body>
</html>
